<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","error.rs"],"content":"use axum::{\n    Json,\n    http::StatusCode,\n    response::{IntoResponse, Response},\n};\nuse serde_json::json;\nuse std::fmt;\n\nuse crate::domain::RepositoryError;\n\n/// API Error types that can be returned by handlers\n#[derive(Debug)]\npub enum ApiError {\n    /// Entity not found (404)\n    NotFound(String),\n    /// Bad request (400)\n    BadRequest(String),\n    /// Conflict (409)\n    Conflict(String),\n    /// Internal server error (500)\n    Internal(String),\n    /// Unauthorized (401)\n    Unauthorized(String),\n    /// Forbidden (403)\n    Forbidden(String),\n}\n\nimpl fmt::Display for ApiError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let message = match self {\n            ApiError::NotFound(msg) =\u003e format!(\"Not found: {}\", msg),\n            ApiError::BadRequest(msg) =\u003e format!(\"Bad request: {}\", msg),\n            ApiError::Conflict(msg) =\u003e format!(\"Conflict: {}\", msg),\n            ApiError::Internal(msg) =\u003e format!(\"Internal error: {}\", msg),\n            ApiError::Unauthorized(msg) =\u003e format!(\"Unauthorized: {}\", msg),\n            ApiError::Forbidden(msg) =\u003e format!(\"Forbidden: {}\", msg),\n        };\n        write!(f, \"{}\", message)\n    }\n}\n\n/// Transform ApiError into an HTTP response\nimpl IntoResponse for ApiError {\n    fn into_response(self) -\u003e Response {\n        let (status, message) = match \u0026self {\n            ApiError::NotFound(msg) =\u003e (StatusCode::NOT_FOUND, msg),\n            ApiError::BadRequest(msg) =\u003e (StatusCode::BAD_REQUEST, msg),\n            ApiError::Conflict(msg) =\u003e (StatusCode::CONFLICT, msg),\n            ApiError::Internal(msg) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, msg),\n            ApiError::Unauthorized(msg) =\u003e (StatusCode::UNAUTHORIZED, msg),\n            ApiError::Forbidden(msg) =\u003e (StatusCode::FORBIDDEN, msg),\n        };\n\n        // Create a JSON response body with error details\n        let body = Json(json!({\n            \"error\": {\n                \"type\": status.canonical_reason(),\n                \"message\": message,\n            }\n        }));\n\n        // Combine the status code and body\n        (status, body).into_response()\n    }\n}\n\n/// Shorthand for API result type\npub type ApiResult\u003cT\u003e = Result\u003cT, ApiError\u003e;\n\n/// Convert from domain RepositoryError to API error\nimpl From\u003cRepositoryError\u003e for ApiError {\n    fn from(err: RepositoryError) -\u003e Self {\n        match err {\n            RepositoryError::NotFound(msg) =\u003e ApiError::NotFound(msg),\n            RepositoryError::Conflict(msg) =\u003e ApiError::Conflict(msg),\n            RepositoryError::Validation(msg) =\u003e ApiError::BadRequest(msg),\n            RepositoryError::Internal(msg) =\u003e ApiError::Internal(msg),\n        }\n    }\n}\n\n/// Maps from RMCP errors to API errors\nimpl From\u003ccrate::mcp::methods::get_symbols::RmcpError\u003e for ApiError {\n    fn from(err: crate::mcp::methods::get_symbols::RmcpError) -\u003e Self {\n        use crate::mcp::methods::get_symbols::{RmcpError, RmcpErrorCode};\n\n        match err {\n            RmcpError::ParseError(msg) =\u003e ApiError::BadRequest(msg),\n            RmcpError::RepositoryError(msg) =\u003e {\n                // For repository errors, we can determine the type based on message content\n                // since we don't have direct access to original RepositoryError\n                if msg.starts_with(\"Not found:\") {\n                    ApiError::NotFound(msg)\n                } else if msg.starts_with(\"Conflict:\") {\n                    ApiError::Conflict(msg)\n                } else if msg.starts_with(\"Validation:\") {\n                    ApiError::BadRequest(msg)\n                } else {\n                    ApiError::Internal(msg)\n                }\n            }\n            RmcpError::Other(msg) =\u003e ApiError::Internal(msg),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_api_error_display() {\n        let error = ApiError::NotFound(\"user\".to_string());\n        assert_eq!(error.to_string(), \"Not found: user\");\n    }\n\n    #[test]\n    fn test_repository_error_conversion() {\n        let repo_error = RepositoryError::NotFound(\"Symbol not found\".to_string());\n        let api_error = ApiError::from(repo_error);\n\n        match api_error {\n            ApiError::NotFound(msg) =\u003e assert_eq!(msg, \"Symbol not found\"),\n            _ =\u003e panic!(\"Conversion produced wrong error type\"),\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":40},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","handlers.rs"],"content":"use axum::{\n    Json,\n    extract::{Path, State},\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nuse super::error::{ApiError, ApiResult};\nuse crate::domain::{Symbol, SymbolRepository};\n\n/// Health check handler\npub async fn health_check() -\u003e \u0026'static str {\n    \"Dream Ontology MCP API is healthy\"\n}\n\n/// Represents a collection of symbols in a response\n#[derive(Serialize)]\npub struct SymbolsResponse {\n    pub symbols: Vec\u003cSymbol\u003e,\n    pub total_count: usize,\n}\n\n/// Query parameters for listing symbols\n#[derive(Deserialize)]\npub struct ListSymbolsQuery {\n    pub category: Option\u003cString\u003e,\n    pub query: Option\u003cString\u003e,\n    #[serde(default = \"default_limit\")]\n    pub limit: usize,\n}\n\n/// Default limit for symbol queries\nfn default_limit() -\u003e usize {\n    50 // Default to 50 symbols\n}\n\n/// List all symbols with optional filtering\npub async fn list_symbols(\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n    Json(params): Json\u003cListSymbolsQuery\u003e,\n) -\u003e ApiResult\u003cJson\u003cSymbolsResponse\u003e\u003e {\n    // Validate input parameters\n    if let Some(ref query) = params.query {\n        if query.trim().is_empty() {\n            return Err(ApiError::BadRequest(\n                \"Search query cannot be empty\".to_string(),\n            ));\n        }\n    }\n\n    if let Some(ref category) = params.category {\n        if category.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Category cannot be empty\".to_string()));\n        }\n    }\n\n    // Determine which repository method to call based on parameters\n    let symbols = match (params.category.as_deref(), params.query.as_deref()) {\n        (_, Some(query)) =\u003e repository.search_symbols(query).await?,\n        (Some(category), None) =\u003e repository.list_symbols(Some(category)).await?,\n        (None, None) =\u003e repository.list_symbols(None).await?,\n    };\n\n    // Apply limit and count\n    let total_count = symbols.len();\n    let symbols = symbols.into_iter().take(params.limit).collect();\n\n    Ok(Json(SymbolsResponse {\n        symbols,\n        total_count,\n    }))\n}\n\n/// Get a specific symbol by ID\npub async fn get_symbol(\n    Path(id): Path\u003cString\u003e,\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n) -\u003e ApiResult\u003cJson\u003cSymbol\u003e\u003e {\n    // Validate ID\n    if id.trim().is_empty() {\n        return Err(ApiError::BadRequest(\n            \"Symbol ID cannot be empty\".to_string(),\n        ));\n    }\n\n    // Retrieve the symbol from repository\n    let symbol = repository.get_symbol(\u0026id).await?;\n    Ok(Json(symbol))\n}\n\n/// Request body for symbol interpretation\n#[derive(Deserialize)]\npub struct InterpretRequest {\n    pub symbol_id: String,\n    pub context: Option\u003cString\u003e,\n    pub query: Option\u003cString\u003e,\n}\n\n/// Response for symbol interpretation\n#[derive(Serialize)]\npub struct InterpretResponse {\n    pub symbol_id: String,\n    pub context: Option\u003cString\u003e,\n    pub interpretation: String,\n}\n\n/// Validate an interpretation request\nfn validate_interpret_request(request: \u0026InterpretRequest) -\u003e Result\u003c(), ApiError\u003e {\n    if request.symbol_id.trim().is_empty() {\n        return Err(ApiError::BadRequest(\n            \"Symbol ID cannot be empty\".to_string(),\n        ));\n    }\n\n    // If context is provided, it shouldn't be empty\n    if let Some(ref context) = request.context {\n        if context.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Context cannot be empty\".to_string()));\n        }\n    }\n\n    // If query is provided, it shouldn't be empty\n    if let Some(ref query) = request.query {\n        if query.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Query cannot be empty\".to_string()));\n        }\n    }\n\n    Ok(())\n}\n\n/// Interpret a symbol\npub async fn interpret_symbol(\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n    Json(request): Json\u003cInterpretRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cInterpretResponse\u003e\u003e {\n    // Validate request\n    validate_interpret_request(\u0026request)?;\n\n    // Check if symbol exists\n    let symbol = repository.get_symbol(\u0026request.symbol_id).await?;\n\n    // For now, we just return a placeholder interpretation\n    // In the future, this would use the LLM client to generate the interpretation\n    let interpretation = format!(\n        \"Interpretation of symbol '{}' with {} and {}.\",\n        symbol.name,\n        request.context.as_deref().unwrap_or(\"no context\"),\n        request.query.as_deref().unwrap_or(\"no query\")\n    );\n\n    Ok(Json(InterpretResponse {\n        symbol_id: request.symbol_id,\n        context: request.context,\n        interpretation,\n    }))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::RepositoryFactory;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let response = health_check().await;\n        assert_eq!(response, \"Dream Ontology MCP API is healthy\");\n    }\n\n    #[tokio::test]\n    async fn test_get_symbol_success() {\n        // Create test repository with data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        // Get the first symbol from the repo to test with\n        let symbols = repository.list_symbols(None).await.unwrap();\n        let first_symbol = symbols.first().unwrap();\n\n        // Test the handler\n        let path = Path(first_symbol.id.clone());\n        let result = get_symbol(path, State(repository)).await;\n\n        assert!(result.is_ok());\n        let symbol = result.unwrap().0; // Extract from Json wrapper\n        assert_eq!(symbol.id, first_symbol.id);\n    }\n\n    #[tokio::test]\n    async fn test_list_symbols() {\n        // Create test repository with data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        // Test with empty params (list all)\n        let params = ListSymbolsQuery {\n            category: None,\n            query: None,\n            limit: 10,\n        };\n\n        let result = list_symbols(State(repository.clone()), Json(params)).await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap().0; // Extract from Json wrapper\n        assert!(!response.symbols.is_empty());\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":40},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","mod.rs"],"content":"pub mod error;\npub mod handlers;\npub mod routes;\n\n// Re-export main router\npub use routes::router;\n// Re-export errors\npub use error::{ApiError, ApiResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","routes.rs"],"content":"use axum::{\n    Router,\n    extract::State,\n    routing::{get, post},\n};\nuse std::sync::Arc;\n\nuse super::handlers;\nuse crate::domain::SymbolRepository;\n\n/// Builds the main application router with all API routes\npub fn router(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e Router {\n    Router::new()\n        .route(\"/health\", get(handlers::health_check))\n        .route(\"/symbols\", get(handlers::list_symbols))\n        .route(\"/symbols/{id}\", get(handlers::get_symbol))\n        .route(\"/interpret\", post(handlers::interpret_symbol))\n        .with_state(symbol_repository)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::RepositoryFactory;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n    #[test]\n    fn test_router_creation() {\n        let factory = MemoryRepositoryFactory::new();\n        let repository = factory.create_symbol_repository();\n\n        let _router = router(repository);\n        // Just testing that it builds - actual routes tested in integration tests\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","config.rs"],"content":"use std::env;\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\n/// Configuration for the application, loaded from environment variables\n#[derive(Debug, Clone)]\npub struct Config {\n    /// Address to bind the HTTP server to (default: 127.0.0.1:3000)\n    pub server_addr: SocketAddr,\n    /// Log level (default: info)\n    pub log_level: String,\n    /// Whether to use in-memory repository (default: true)\n    pub use_memory_repository: bool,\n}\n\nimpl Default for Config {\n    fn default() -\u003e Self {\n        Self {\n            server_addr: SocketAddr::from(([127, 0, 0, 1], 3000)),\n            log_level: \"info\".to_string(),\n            use_memory_repository: true,\n        }\n    }\n}\n\nimpl Config {\n    /// Load configuration from environment variables\n    pub fn from_env() -\u003e Self {\n        let server_addr = env::var(\"SERVER_ADDR\")\n            .ok()\n            .and_then(|addr| SocketAddr::from_str(\u0026addr).ok())\n            .unwrap_or_else(|| SocketAddr::from(([127, 0, 0, 1], 3000)));\n\n        let log_level = env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\n\n        let use_memory_repository = env::var(\"USE_MEMORY_REPOSITORY\")\n            .map(|val| val.to_lowercase() == \"true\" || val == \"1\")\n            .unwrap_or(true);\n\n        Self {\n            server_addr,\n            log_level,\n            use_memory_repository,\n        }\n    }\n\n    /// Get the tracing filter based on the log level\n    pub fn get_tracing_filter(\u0026self) -\u003e String {\n        format!(\n            \"dream_ontology_mcp={},tower_http={}\",\n            self.log_level, self.log_level\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.server_addr.to_string(), \"127.0.0.1:3000\");\n        assert_eq!(config.log_level, \"info\");\n        assert!(config.use_memory_repository);\n    }\n\n    #[test]\n    fn test_get_tracing_filter() {\n        let config = Config {\n            log_level: \"debug\".to_string(),\n            ..Config::default()\n        };\n        assert_eq!(\n            config.get_tracing_filter(),\n            \"dream_ontology_mcp=debug,tower_http=debug\"\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}}],"covered":6,"coverable":13},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","mod.rs"],"content":"/*!\n * # Domain Module\n *\n * The domain module contains the core business logic and models for the symbolic reasoning engine.\n * This includes:\n *\n * - **Symbol**: Represents a symbolic entity with interpretations and relationships\n * - **SymbolSet**: A collection of related symbols organized into an ontology\n * - **Repository**: Interfaces for persistence and data access\n *\n * The domain layer is designed to be persistence-agnostic, with implementations\n * provided in the infrastructure layer.\n */\n\n// Domain module exports\npub mod ontology;\npub mod repository;\npub mod symbols;\n\n// Re-exports for convenient access\npub use ontology::SymbolSet;\npub use repository::{\n    RepositoryError, RepositoryFactory, RepositoryResult, SymbolRepository, SymbolSetRepository,\n};\npub use symbols::Symbol;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","ontology.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\n\nuse super::symbols::Symbol;\n\n/// Represents a collection of symbols organized into an ontology\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SymbolSet {\n    /// Unique identifier for the symbol set\n    pub id: String,\n\n    /// Name of the symbol set\n    pub name: String,\n\n    /// Description of the symbol set\n    pub description: String,\n\n    /// Category of the symbol set (e.g., \"dream\", \"mythological\")\n    pub category: String,\n\n    /// Symbols contained in this set, indexed by ID\n    #[serde(default)]\n    pub symbols: HashMap\u003cString, Symbol\u003e,\n}\n\nimpl SymbolSet {\n    /// Create a new empty symbol set\n    pub fn new(id: String, name: String, category: String, description: String) -\u003e Self {\n        SymbolSet {\n            id,\n            name,\n            category,\n            description,\n            symbols: HashMap::new(),\n        }\n    }\n\n    /// Create a new symbol set with initial symbols\n    pub fn with_symbols(mut self, symbol_ids: Vec\u003c\u0026str\u003e) -\u003e Self {\n        // Note: This just stores empty placeholders - typically you'd populate\n        // with real symbols later through the repository\n        for id in symbol_ids {\n            self.symbols.insert(\n                id.to_string(),\n                Symbol::new(\n                    id.to_string(),\n                    id.to_string(), // Using ID as name for placeholder\n                    \"\".to_string(), // Empty category\n                    \"\".to_string(), // Empty description\n                ),\n            );\n        }\n        self\n    }\n\n    /// Add a symbol to the set\n    pub fn add_symbol(\u0026mut self, symbol: Symbol) -\u003e Option\u003cSymbol\u003e {\n        self.symbols.insert(symbol.id.clone(), symbol)\n    }\n\n    /// Get a symbol by ID\n    pub fn get_symbol(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(id)\n    }\n\n    /// Remove a symbol by ID\n    pub fn remove_symbol(\u0026mut self, id: \u0026str) -\u003e Option\u003cSymbol\u003e {\n        self.symbols.remove(id)\n    }\n\n    /// Search for symbols matching a query in name or description\n    pub fn search(\u0026self, query: \u0026str) -\u003e Vec\u003c\u0026Symbol\u003e {\n        let query = query.to_lowercase();\n        self.symbols\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .collect()\n    }\n\n    /// Filter symbols by category\n    pub fn filter_by_category(\u0026self, category: \u0026str) -\u003e Vec\u003c\u0026Symbol\u003e {\n        self.symbols\n            .values()\n            .filter(|s| s.category == category)\n            .collect()\n    }\n\n    /// Get all unique categories in this symbol set\n    pub fn get_categories(\u0026self) -\u003e HashSet\u003c\u0026str\u003e {\n        self.symbols.values().map(|s| s.category.as_str()).collect()\n    }\n\n    /// Count the symbols in this set\n    pub fn count(\u0026self) -\u003e usize {\n        self.symbols.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_symbol(id: \u0026str, name: \u0026str, category: \u0026str) -\u003e Symbol {\n        Symbol::new(\n            id.to_string(),\n            name.to_string(),\n            category.to_string(),\n            format!(\"Description for {}\", name),\n        )\n    }\n\n    #[test]\n    fn test_symbolset_creation() {\n        let symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        assert_eq!(symbol_set.id, \"dream-symbols\");\n        assert_eq!(symbol_set.name, \"Dream Symbols\");\n        assert_eq!(symbol_set.description, \"Common symbols appearing in dreams\");\n        assert_eq!(symbol_set.count(), 0);\n    }\n\n    #[test]\n    fn test_add_and_get_symbol() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        let water = create_test_symbol(\"water\", \"Water\", \"dream\");\n        let fire = create_test_symbol(\"fire\", \"Fire\", \"dream\");\n\n        symbol_set.add_symbol(water);\n        symbol_set.add_symbol(fire);\n\n        assert_eq!(symbol_set.count(), 2);\n\n        let retrieved = symbol_set.get_symbol(\"water\").unwrap();\n        assert_eq!(retrieved.name, \"Water\");\n\n        // Test replacing a symbol\n        let new_water = create_test_symbol(\"water\", \"Water (Updated)\", \"dream\");\n        symbol_set.add_symbol(new_water);\n\n        // Should still have 2 symbols\n        assert_eq!(symbol_set.count(), 2);\n\n        // But the water symbol should be updated\n        let updated = symbol_set.get_symbol(\"water\").unwrap();\n        assert_eq!(updated.name, \"Water (Updated)\");\n    }\n\n    #[test]\n    fn test_remove_symbol() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n\n        assert_eq!(symbol_set.count(), 2);\n\n        let removed = symbol_set.remove_symbol(\"water\").unwrap();\n        assert_eq!(removed.name, \"Water\");\n        assert_eq!(symbol_set.count(), 1);\n        assert!(symbol_set.get_symbol(\"water\").is_none());\n    }\n\n    #[test]\n    fn test_search() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"ocean\", \"Ocean\", \"dream\"));\n\n        let results = symbol_set.search(\"wat\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"water\");\n\n        // Search is case-insensitive\n        let results = symbol_set.search(\"WATER\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"water\");\n    }\n\n    #[test]\n    fn test_filter_by_category() {\n        let mut symbol_set = SymbolSet::new(\n            \"mixed-symbols\".to_string(),\n            \"Mixed Symbols\".to_string(),\n            \"mixed\".to_string(),\n            \"Mixed symbol categories\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"dragon\", \"Dragon\", \"mythological\"));\n        symbol_set.add_symbol(create_test_symbol(\"phoenix\", \"Phoenix\", \"mythological\"));\n\n        let dream_symbols = symbol_set.filter_by_category(\"dream\");\n        assert_eq!(dream_symbols.len(), 2);\n\n        let myth_symbols = symbol_set.filter_by_category(\"mythological\");\n        assert_eq!(myth_symbols.len(), 2);\n\n        // Check empty result for non-existent category\n        let empty = symbol_set.filter_by_category(\"nonexistent\");\n        assert_eq!(empty.len(), 0);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":39}},{"line":34,"address":[],"length":0,"stats":{"Line":39}},{"line":39,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":276}},{"line":43,"address":[],"length":0,"stats":{"Line":84}},{"line":44,"address":[],"length":0,"stats":{"Line":84}},{"line":45,"address":[],"length":0,"stats":{"Line":84}},{"line":46,"address":[],"length":0,"stats":{"Line":84}},{"line":47,"address":[],"length":0,"stats":{"Line":84}},{"line":48,"address":[],"length":0,"stats":{"Line":84}},{"line":49,"address":[],"length":0,"stats":{"Line":84}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":57,"address":[],"length":0,"stats":{"Line":32}},{"line":58,"address":[],"length":0,"stats":{"Line":32}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":7}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":28}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":87,"address":[],"length":0,"stats":{"Line":51}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":14}}],"covered":29,"coverable":31},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","repository.rs"],"content":"use crate::domain::{Symbol, SymbolSet};\nuse async_trait::async_trait;\nuse std::error::Error;\nuse std::fmt::{Display, Formatter};\nuse std::sync::Arc;\n\n/// Domain-specific error type for repository operations\n#[derive(Debug)]\npub enum RepositoryError {\n    /// Entity not found\n    NotFound(String),\n    /// Conflict with existing entity\n    Conflict(String),\n    /// Internal repository error\n    Internal(String),\n    /// Validation error\n    Validation(String),\n}\n\nimpl Display for RepositoryError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::NotFound(msg) =\u003e write!(f, \"Not found: {}\", msg),\n            Self::Conflict(msg) =\u003e write!(f, \"Conflict: {}\", msg),\n            Self::Internal(msg) =\u003e write!(f, \"Internal error: {}\", msg),\n            Self::Validation(msg) =\u003e write!(f, \"Validation error: {}\", msg),\n        }\n    }\n}\n\nimpl Error for RepositoryError {}\n\npub type RepositoryResult\u003cT\u003e = Result\u003cT, RepositoryError\u003e;\n\n/// Repository trait for Symbol entities\n#[async_trait]\npub trait SymbolRepository: Send + Sync {\n    /// Get a symbol by its ID\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// List all symbols, optionally filtering by category\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e;\n\n    /// Search for symbols containing the query in name or description\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e;\n\n    /// Create a new symbol\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// Update an existing symbol\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// Delete a symbol by its ID\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e;\n}\n\n/// Repository trait for SymbolSet entities\n#[async_trait]\npub trait SymbolSetRepository: Send + Sync {\n    /// Get a symbol set by its ID\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// List all symbol sets, optionally filtering by category\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e;\n\n    /// Search for symbol sets containing the query in name or description\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e;\n\n    /// Create a new symbol set\n    async fn create_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// Update an existing symbol set\n    async fn update_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// Delete a symbol set by its ID\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e;\n}\n\n/// Factory for creating repository instances\npub trait RepositoryFactory {\n    /// Create a new symbol repository\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e;\n\n    /// Create a new symbol set repository\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e;\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":6},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","symbols.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Represents a symbolic entity with its properties and interpretations\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Symbol {\n    /// Unique identifier for the symbol\n    pub id: String,\n\n    /// Name of the symbol\n    pub name: String,\n\n    /// Primary category (dream, mythological, archetypal, etc.)\n    pub category: String,\n\n    /// Brief description of the symbol\n    pub description: String,\n\n    /// Detailed interpretations across different contexts\n    pub interpretations: HashMap\u003cString, String\u003e,\n\n    /// Related symbols (by ID)\n    pub related_symbols: Vec\u003cString\u003e,\n\n    /// Additional properties as key-value pairs\n    #[serde(default)]\n    pub properties: HashMap\u003cString, String\u003e,\n}\n\nimpl Symbol {\n    /// Create a new symbol with minimal fields\n    pub fn new(id: String, name: String, category: String, description: String) -\u003e Self {\n        Symbol {\n            id,\n            name,\n            category,\n            description,\n            interpretations: HashMap::new(),\n            related_symbols: Vec::new(),\n            properties: HashMap::new(),\n        }\n    }\n\n    /// Set or update the category\n    pub fn with_category(mut self, category: \u0026str) -\u003e Self {\n        self.category = category.to_string();\n        self\n    }\n\n    /// Add related symbols\n    pub fn with_related(mut self, related: Vec\u003c\u0026str\u003e) -\u003e Self {\n        self.related_symbols = related.into_iter().map(|s| s.to_string()).collect();\n        self\n    }\n\n    /// Add an interpretation for a specific context\n    pub fn add_interpretation(\u0026mut self, context: String, interpretation: String) {\n        self.interpretations.insert(context, interpretation);\n    }\n\n    /// Add a related symbol by ID\n    pub fn add_related_symbol(\u0026mut self, symbol_id: String) {\n        if !self.related_symbols.contains(\u0026symbol_id) {\n            self.related_symbols.push(symbol_id);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_symbol_creation() {\n        let symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        assert_eq!(symbol.id, \"water\");\n        assert_eq!(symbol.name, \"Water\");\n        assert_eq!(symbol.category, \"dream\");\n        assert_eq!(\n            symbol.description,\n            \"Symbolizes emotions and the unconscious\"\n        );\n        assert!(symbol.interpretations.is_empty());\n        assert!(symbol.related_symbols.is_empty());\n    }\n\n    #[test]\n    fn test_add_interpretation() {\n        let mut symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        symbol.add_interpretation(\n            \"psychology\".to_string(),\n            \"Represents the depths of the unconscious mind\".to_string(),\n        );\n\n        assert_eq!(\n            symbol.interpretations.get(\"psychology\").unwrap(),\n            \"Represents the depths of the unconscious mind\"\n        );\n    }\n\n    #[test]\n    fn test_add_related_symbol() {\n        let mut symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        symbol.add_related_symbol(\"ocean\".to_string());\n        symbol.add_related_symbol(\"river\".to_string());\n        // Adding duplicate should not add it again\n        symbol.add_related_symbol(\"ocean\".to_string());\n\n        assert_eq!(symbol.related_symbols.len(), 2);\n        assert!(symbol.related_symbols.contains(\u0026\"ocean\".to_string()));\n        assert!(symbol.related_symbols.contains(\u0026\"river\".to_string()));\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":185}},{"line":38,"address":[],"length":0,"stats":{"Line":185}},{"line":39,"address":[],"length":0,"stats":{"Line":185}},{"line":40,"address":[],"length":0,"stats":{"Line":185}},{"line":45,"address":[],"length":0,"stats":{"Line":60}},{"line":46,"address":[],"length":0,"stats":{"Line":60}},{"line":47,"address":[],"length":0,"stats":{"Line":60}},{"line":51,"address":[],"length":0,"stats":{"Line":60}},{"line":52,"address":[],"length":0,"stats":{"Line":240}},{"line":53,"address":[],"length":0,"stats":{"Line":60}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":9}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":7}}],"covered":15,"coverable":15},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","infrastructure","memory_repository.rs"],"content":"use crate::domain::{\n    RepositoryError, RepositoryFactory, RepositoryResult, Symbol, SymbolRepository, SymbolSet,\n    SymbolSetRepository,\n};\nuse async_trait;\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex, RwLock};\n\n/// Generic repository trait for basic CRUD operations\npub trait Repository\u003cK, V\u003e {\n    /// Get an item by its key\n    fn get(\u0026self, key: \u0026K) -\u003e Result\u003cOption\u003cV\u003e, RepositoryError\u003e;\n\n    /// Save an item with the given key\n    fn save(\u0026self, key: K, value: V) -\u003e Result\u003c(), RepositoryError\u003e;\n\n    /// Delete an item by its key, returns true if item was deleted\n    fn delete(\u0026self, key: \u0026K) -\u003e Result\u003cbool, RepositoryError\u003e;\n\n    /// List all items as key-value pairs\n    fn list(\u0026self) -\u003e Result\u003cVec\u003c(K, V)\u003e, RepositoryError\u003e;\n}\n\n/// In-memory implementation of the repositories for testing and development\n#[derive(Default, Clone)]\npub struct MemoryRepositoryFactory {\n    symbols: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n    symbol_sets: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n}\n\nimpl MemoryRepositoryFactory {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        // Load test data\n        let test_symbols = vec![\n            Symbol::new(\n                \"sun\".to_string(),\n                \"Sun\".to_string(),\n                \"nature\".to_string(),\n                \"Celestial body at the center of our solar system\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"light\", \"day\"]),\n            Symbol::new(\n                \"moon\".to_string(),\n                \"Moon\".to_string(),\n                \"nature\".to_string(),\n                \"Natural satellite of Earth\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"night\", \"tide\"]),\n            Symbol::new(\n                \"light\".to_string(),\n                \"Light\".to_string(),\n                \"concept\".to_string(),\n                \"Electromagnetic radiation visible to the human eye\".to_string(),\n            )\n            .with_category(\"concept\")\n            .with_related(vec![\"sun\", \"illumination\"]),\n            Symbol::new(\n                \"dark\".to_string(),\n                \"Darkness\".to_string(),\n                \"concept\".to_string(),\n                \"Absence of light\".to_string(),\n            )\n            .with_category(\"concept\")\n            .with_related(vec![\"night\", \"shadow\"]),\n            Symbol::new(\n                \"tree\".to_string(),\n                \"Tree\".to_string(),\n                \"nature\".to_string(),\n                \"Perennial plant with an elongated stem and branches\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"forest\", \"wood\"]),\n        ];\n\n        let test_sets = vec![\n            SymbolSet::new(\n                \"celestial\".to_string(),\n                \"Celestial Bodies\".to_string(),\n                \"nature\".to_string(),\n                \"Celestial bodies and phenomena\".to_string(),\n            )\n            .with_symbols(vec![\"sun\", \"moon\", \"star\"]),\n            SymbolSet::new(\n                \"opposites\".to_string(),\n                \"Opposing Concepts\".to_string(),\n                \"concept\".to_string(),\n                \"Paired opposing concepts\".to_string(),\n            )\n            .with_symbols(vec![\"light\", \"dark\", \"day\", \"night\"]),\n        ];\n\n        // Insert test data\n        {\n            let mut symbols = self.symbols.write().unwrap();\n            for symbol in test_symbols {\n                symbols.insert(symbol.id.clone(), symbol);\n            }\n\n            let mut symbol_sets = self.symbol_sets.write().unwrap();\n            for set in test_sets {\n                symbol_sets.insert(set.id.clone(), set);\n            }\n        }\n\n        self\n    }\n}\n\nimpl RepositoryFactory for MemoryRepositoryFactory {\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e {\n        Arc::new(MemorySymbolRepository {\n            data: Arc::clone(\u0026self.symbols),\n        })\n    }\n\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e {\n        Arc::new(MemorySymbolSetRepository {\n            data: Arc::clone(\u0026self.symbol_sets),\n        })\n    }\n}\n\n/// In-memory implementation of SymbolRepository\nstruct MemorySymbolRepository {\n    data: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n}\n\n#[async_trait::async_trait]\nimpl SymbolRepository for MemorySymbolRepository {\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let symbols = self.data.read().unwrap();\n        symbols\n            .get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                id\n            )))\n    }\n\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        let symbols = self.data.read().unwrap();\n        let result = match category {\n            Some(cat) =\u003e symbols\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e symbols.values().cloned().collect(),\n        };\n        Ok(result)\n    }\n\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        let symbols = self.data.read().unwrap();\n        let query = query.to_lowercase();\n\n        let result = symbols\n            .values()\n            .filter(|s| {\n                s.id.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(result)\n    }\n\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol already exists\n        if symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"Symbol already exists: {}\",\n                symbol.id\n            )));\n        }\n\n        // Insert the new symbol\n        let result = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n\n        Ok(result)\n    }\n\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol exists\n        if !symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                symbol.id\n            )));\n        }\n\n        // Update the symbol\n        let result = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n\n        Ok(result)\n    }\n\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol exists\n        if !symbols.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                id\n            )));\n        }\n\n        // Remove the symbol\n        symbols.remove(id);\n\n        Ok(())\n    }\n}\n\n/// In-memory implementation of SymbolSetRepository\nstruct MemorySymbolSetRepository {\n    data: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n}\n\n#[async_trait::async_trait]\nimpl SymbolSetRepository for MemorySymbolSetRepository {\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let sets = self.data.read().unwrap();\n        sets.get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                id\n            )))\n    }\n\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        let sets = self.data.read().unwrap();\n        let result = match category {\n            Some(cat) =\u003e sets\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e sets.values().cloned().collect(),\n        };\n        Ok(result)\n    }\n\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        let sets = self.data.read().unwrap();\n        let query = query.to_lowercase();\n\n        let result = sets\n            .values()\n            .filter(|s| {\n                s.id.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(result)\n    }\n\n    async fn create_symbol_set(\u0026self, set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set already exists\n        if sets.contains_key(\u0026set.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"SymbolSet already exists: {}\",\n                set.id\n            )));\n        }\n\n        // Insert the new set\n        let result = set.clone();\n        sets.insert(set.id.clone(), set);\n\n        Ok(result)\n    }\n\n    async fn update_symbol_set(\u0026self, set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set exists\n        if !sets.contains_key(\u0026set.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                set.id\n            )));\n        }\n\n        // Update the set\n        let result = set.clone();\n        sets.insert(set.id.clone(), set);\n\n        Ok(result)\n    }\n\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set exists\n        if !sets.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                id\n            )));\n        }\n\n        // Remove the set\n        sets.remove(id);\n\n        Ok(())\n    }\n}\n\n/// An in-memory implementation of the Repository trait.\n/// This is primarily useful for testing and prototyping.\npub struct MemoryRepository\u003cK, V\u003e {\n    data: Arc\u003cMutex\u003cHashMap\u003cK, V\u003e\u003e\u003e,\n}\n\nimpl\u003cK, V\u003e MemoryRepository\u003cK, V\u003e\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    /// Create a new empty memory repository\n    pub fn new() -\u003e Self {\n        Self {\n            data: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    /// Create a memory repository with initial data\n    pub fn with_data(initial_data: HashMap\u003cK, V\u003e) -\u003e Self {\n        Self {\n            data: Arc::new(Mutex::new(initial_data)),\n        }\n    }\n}\n\nimpl\u003cK, V\u003e Repository\u003cK, V\u003e for MemoryRepository\u003cK, V\u003e\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    fn get(\u0026self, key: \u0026K) -\u003e Result\u003cOption\u003cV\u003e, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(data) =\u003e Ok(data.get(key).cloned()),\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn save(\u0026self, key: K, value: V) -\u003e Result\u003c(), RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(mut data) =\u003e {\n                data.insert(key, value);\n                Ok(())\n            }\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn delete(\u0026self, key: \u0026K) -\u003e Result\u003cbool, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(mut data) =\u003e Ok(data.remove(key).is_some()),\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn list(\u0026self) -\u003e Result\u003cVec\u003c(K, V)\u003e, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(data) =\u003e {\n                let items = data.iter().map(|(k, v)| (k.clone(), v.clone())).collect();\n                Ok(items)\n            }\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":15}},{"line":33,"address":[],"length":0,"stats":{"Line":15}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":12}},{"line":42,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":45,"address":[],"length":0,"stats":{"Line":12}},{"line":46,"address":[],"length":0,"stats":{"Line":12}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":12}},{"line":64,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":67,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":12}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":192}},{"line":102,"address":[],"length":0,"stats":{"Line":60}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":106,"address":[],"length":0,"stats":{"Line":84}},{"line":107,"address":[],"length":0,"stats":{"Line":24}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":15}},{"line":118,"address":[],"length":0,"stats":{"Line":15}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":9}},{"line":148,"address":[],"length":0,"stats":{"Line":9}},{"line":149,"address":[],"length":0,"stats":{"Line":18}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":9}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}}],"covered":84,"coverable":188},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","infrastructure","mod.rs"],"content":"/// Infrastructure layer for MCP\n/// Contains implementations of the domain interfaces\npub mod memory_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","lib.rs"],"content":"/*!\n * # Dream Ontology MCP Library\n *\n * This library implements a symbolic reasoning engine for dream interpretation\n * and symbolic analysis through the Model Context Protocol (MCP).\n *\n * ## Core Components\n *\n * - **Domain Models**: Define the core business objects like `Symbol` and `SymbolSet`\n * - **MCP Implementation**: Protocol-compliant methods for symbolic reasoning\n * - **Infrastructure**: Repository implementations and external integrations\n *\n * ## Usage Example\n *\n * ```rust\n * use dream_ontology_mcp::domain::{Symbol, SymbolRepository};\n * use dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\n *\n * // Create a repository with test data\n * let repo_factory = MemoryRepositoryFactory::new().with_test_data();\n * let symbol_repo = repo_factory.create_symbol_repository();\n *\n * // Use the repository asynchronously\n * async fn get_water_symbol(repo: Arc\u003cdyn SymbolRepository\u003e) -\u003e Option\u003cSymbol\u003e {\n *     repo.get(\"water\").await.ok()\n * }\n * ```\n */\n\n// Re-export all modules for better ergonomics\n\n/// Core domain models and business logic\npub mod domain;\n\n/// MCP protocol implementation for symbolic reasoning\npub mod mcp;\n\n/// Infrastructure implementations for repositories and external services\npub mod infrastructure;\n\n/// Utility functions and shared helpers\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","client.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::error::Error;\n\n/// A simple LLM client for interacting with OpenRouter\n#[derive(Debug, Clone)]\npub struct LlmClient {\n    api_key: String,\n    model: String,\n    base_url: String,\n}\n\n/// Request structure for LLM completions\n#[derive(Debug, Serialize)]\npub struct CompletionRequest {\n    pub model: String,\n    pub messages: Vec\u003cMessage\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub temperature: Option\u003cf32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_tokens: Option\u003cu32\u003e,\n}\n\n/// Message structure for LLM conversations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Message {\n    pub role: String,\n    pub content: String,\n}\n\n/// Response from LLM completion requests\n#[derive(Debug, Deserialize)]\npub struct CompletionResponse {\n    pub id: String,\n    pub choices: Vec\u003cChoice\u003e,\n}\n\n/// A single completion choice\n#[derive(Debug, Deserialize)]\npub struct Choice {\n    pub message: Message,\n    pub finish_reason: String,\n}\n\nimpl LlmClient {\n    /// Create a new LLM client\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        LlmClient {\n            api_key,\n            model,\n            base_url: \"https://openrouter.ai/api/v1\".to_string(),\n        }\n    }\n\n    /// Create a client with the default DeepSeek model\n    pub fn with_default_model(api_key: String) -\u003e Self {\n        Self::new(api_key, \"deepseek/deepseek-chat\".to_string())\n    }\n\n    /// Generate a completion for the given prompt\n    pub async fn generate(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n        // This is a stub implementation\n        // In a real implementation, we would make an HTTP request to the OpenRouter API\n\n        // For now, just return a mock response\n        Ok(format!(\"LLM response to: {}\", prompt))\n    }\n\n    /// Generate a completion with a system prompt and user message\n    pub async fn chat(\n        \u0026self,\n        system_prompt: \u0026str,\n        user_message: \u0026str,\n    ) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n        // This is just preparing the messages - we're not using them yet in this stub\n        let _messages = vec![\n            Message {\n                role: \"system\".to_string(),\n                content: system_prompt.to_string(),\n            },\n            Message {\n                role: \"user\".to_string(),\n                content: user_message.to_string(),\n            },\n        ];\n\n        // This is a stub implementation\n        Ok(format!(\n            \"LLM chat response to system: '{}' and user: '{}'\",\n            system_prompt, user_message\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_generate() {\n        let client = LlmClient::with_default_model(\"test-key\".to_string());\n        let result = client\n            .generate(\"What is the meaning of water in dreams?\")\n            .await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n        assert!(response.contains(\"LLM response to:\"));\n    }\n\n    #[tokio::test]\n    async fn test_chat() {\n        let client = LlmClient::with_default_model(\"test-key\".to_string());\n        let result = client\n            .chat(\n                \"You are a dream symbol interpreter\",\n                \"What does water represent in dreams?\",\n            )\n            .await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n        assert!(response.contains(\"LLM chat response\"));\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","mod.rs"],"content":"pub mod client;\npub mod prompts;\n\n// No re-exports for now as we're not using them directly yet\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","prompts.rs"],"content":"use crate::domain::Symbol;\n\n/// Template for the system prompt when interpreting symbols\npub const SYSTEM_PROMPT: \u0026str = r#\"\nYou are an expert interpreter of symbolic content, specializing in {category} symbolism.\nYou provide insightful, nuanced interpretations based on established psychological and cultural frameworks.\nRespond with clear, thoughtful analysis without unnecessary disclaimers.\nBase your interpretations on established symbolic meanings and psychological principles.\n\"#;\n\n/// Builds a system prompt for a specific symbol category\npub fn build_system_prompt(category: \u0026str) -\u003e String {\n    SYSTEM_PROMPT.replace(\"{category}\", category)\n}\n\n/// Template for the user prompt when interpreting a specific symbol\npub const SYMBOL_PROMPT: \u0026str = r#\"\nInterpret the symbol \"{symbol_name}\" which is described as: {symbol_description}\n\n{context_instruction}\n\n{specific_query}\n\nProvide a structured interpretation that includes:\n1. Core symbolic meaning\n2. Psychological significance\n3. Cultural and historical context\n4. Practical implications\n\"#;\n\n/// Builds a user prompt for interpreting a symbol\npub fn build_symbol_prompt(symbol: \u0026Symbol, context: Option\u003c\u0026str\u003e, query: Option\u003c\u0026str\u003e) -\u003e String {\n    let context_instruction = match context {\n        Some(ctx) =\u003e format!(\"Consider the specific context: {}\", ctx),\n        None =\u003e \"Consider general interpretive contexts\".to_string(),\n    };\n\n    let specific_query = match query {\n        Some(q) =\u003e format!(\"Specifically address this question: {}\", q),\n        None =\u003e \"Provide a general interpretation\".to_string(),\n    };\n\n    SYMBOL_PROMPT\n        .replace(\"{symbol_name}\", \u0026symbol.name)\n        .replace(\"{symbol_description}\", \u0026symbol.description)\n        .replace(\"{context_instruction}\", \u0026context_instruction)\n        .replace(\"{specific_query}\", \u0026specific_query)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    fn create_test_symbol() -\u003e Symbol {\n        Symbol {\n            id: \"water\".to_string(),\n            name: \"Water\".to_string(),\n            category: \"dream\".to_string(),\n            description: \"Symbolizes emotions and the unconscious\".to_string(),\n            interpretations: HashMap::new(),\n            related_symbols: vec![\"ocean\".to_string()],\n            properties: HashMap::new(),\n        }\n    }\n\n    #[test]\n    fn test_build_system_prompt() {\n        let prompt = build_system_prompt(\"dream\");\n        assert!(prompt.contains(\"dream symbolism\"));\n    }\n\n    #[test]\n    fn test_build_symbol_prompt() {\n        let symbol = create_test_symbol();\n\n        // Test with no context or query\n        let basic_prompt = build_symbol_prompt(\u0026symbol, None, None);\n        assert!(basic_prompt.contains(\"Water\"));\n        assert!(basic_prompt.contains(\"Symbolizes emotions and the unconscious\"));\n        assert!(basic_prompt.contains(\"Consider general interpretive contexts\"));\n        assert!(basic_prompt.contains(\"Provide a general interpretation\"));\n\n        // Test with context and query\n        let detailed_prompt = build_symbol_prompt(\n            \u0026symbol,\n            Some(\"recurring nightmares\"),\n            Some(\"Why does this symbol appear during times of stress?\"),\n        );\n\n        assert!(detailed_prompt.contains(\"Consider the specific context: recurring nightmares\"));\n        assert!(detailed_prompt.contains(\"Specifically address this question: Why does this symbol appear during times of stress?\"));\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}}],"covered":14,"coverable":14},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","logging.rs"],"content":"use axum::Router;\nuse axum::body::Body;\nuse axum::http::{Request, StatusCode};\nuse std::time::Duration;\nuse tower_http::classify::{ServerErrorsAsFailures, SharedClassifier};\nuse tower_http::trace::{self, TraceLayer};\nuse tracing::{Level, info, warn};\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\n\nuse crate::config::Config;\n\n/// Initialize the tracing subscriber based on the provided configuration\npub fn init_tracing(config: \u0026Config) {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| config.get_tracing_filter().into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n}\n\n/// Creates a trace layer for HTTP request and response logging.\n///\n/// This function returns a TraceLayer configured with custom behavior for logging\n/// HTTP requests and responses, with specific handling for different status codes.\n///\n/// # Returns\n///\n/// A configured `TraceLayer` middleware that can be added to an Axum router.\n///\n/// # Example\n///\n/// ```\n/// use axum::Router;\n/// use crate::logging::trace_layer;\n///\n/// let app = Router::new()\n///     .route(\"/\", get(|| async { \"Hello, World!\" }))\n///     .layer(trace_layer());\n/// ```\npub fn trace_layer() -\u003e TraceLayer\u003c\n    SharedClassifier\u003cServerErrorsAsFailures\u003e,\n    trace::DefaultMakeSpan,\n    impl Fn(\u0026Request\u003cBody\u003e, \u0026tracing::Span) + Copy,\n    impl Fn(\u0026axum::http::Response\u003cBody\u003e, Duration, \u0026tracing::Span) + Copy,\n\u003e {\n    tower_http::trace::TraceLayer::new_for_http()\n        .make_span_with(tower_http::trace::DefaultMakeSpan::new().level(Level::INFO))\n        .on_request(|request: \u0026Request\u003c_\u003e, _span: \u0026tracing::Span| {\n            info!(\n                \"Request: {} {} {:?}\",\n                request.method(),\n                request.uri(),\n                request.version()\n            );\n        })\n        .on_response(\n            |response: \u0026axum::http::Response\u003cBody\u003e, latency: Duration, _span: \u0026tracing::Span| {\n                let status = response.status();\n                let latency = format!(\"{:.3} ms\", latency.as_secs_f64() * 1000.0);\n\n                if status.is_success() {\n                    info!(\n                        \"Response: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                } else if status.is_server_error() {\n                    warn!(\n                        \"Server error: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                } else {\n                    info!(\n                        \"Non-success response: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                }\n            },\n        )\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","main.rs"],"content":"use std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse axum::serve;\nuse tokio::net::TcpListener;\nuse tracing::{debug, info};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\nuse crate::config::Config;\nuse crate::domain::RepositoryFactory;\nuse crate::infrastructure::memory_repository::MemoryRepositoryFactory;\nuse crate::logging::{init_tracing, trace_layer};\n\n/// API module containing HTTP endpoints and request handlers\nmod api;\n\n/// Configuration module for loading and managing application settings\nmod config;\n\n/// Domain module containing core business logic and models\nmod domain;\n\n/// Infrastructure module for external integrations and persistence\nmod infrastructure;\n\n// TODO: This module belongs to the Dream Interpretation Backend, not the Symbolic Ontology\n/// LLM integration module for language model interaction\nmod llm;\n\n/// Logging configuration and utilities\nmod logging;\n\n/// MCP implementation for protocol-compliant symbolic reasoning\nmod mcp;\n\n/// Utility functions and shared helpers\nmod utils;\n\n/// Main application entry point for the Dream Ontology Symbolic MCP Server.\n///\n/// This starts an Axum-based HTTP server that provides:\n/// 1. REST API endpoints for symbol and ontology management\n/// 2. MCP protocol endpoints for semantic reasoning\n///\n/// The server uses a repository pattern to abstract data access, with\n/// in-memory implementation available for development and testing.\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Load configuration from environment\n    let config = Config::from_env();\n\n    // Initialize tracing with config\n    init_tracing(\u0026config);\n\n    info!(\n        \"Starting Dream Ontology Symbolic MCP Server v{}\",\n        utils::version()\n    );\n\n    debug!(?config, \"Loaded configuration\");\n\n    // Initialize repositories based on configuration\n    let repo_factory = if config.use_memory_repository {\n        info!(\"Using in-memory repository with test data\");\n        MemoryRepositoryFactory::new().with_test_data()\n    } else {\n        // In the future, we could add other repository implementations here\n        info!(\"Using in-memory repository (default)\");\n        MemoryRepositoryFactory::new().with_test_data()\n    };\n\n    let symbol_repository = repo_factory.create_symbol_repository();\n\n    // Create the API router with repository dependency and logging middleware\n    let app = api::router(symbol_repository.clone()).layer(trace_layer());\n\n    // TODO: Initialize MCP server with method handlers\n    // using the same repository\n    debug!(\"API Server initialized with symbol repository and logging middleware\");\n\n    // Start HTTP server\n    info!(\"API Server listening on {}\", config.server_addr);\n\n    // Create a TCP listener and serve with Axum\n    let listener = TcpListener::bind(\u0026config.server_addr).await?;\n    axum::serve(listener, app.into_make_service()).await?;\n\n    info!(\"Server shutting down\");\n\n    Ok(())\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","methods","get_symbols.rs"],"content":"use async_trait::async_trait;\nuse serde_json;\nuse std::error::Error as StdError;\nuse std::fmt;\nuse std::sync::Arc;\n\nuse crate::domain::{RepositoryError, RepositoryFactory, Symbol, SymbolRepository};\nuse crate::mcp::schema::{GetSymbolsParams, GetSymbolsResponse, SymbolDTO};\n\n/// Handler trait definition\n#[async_trait]\npub trait Handler: Send + Sync {\n    fn method_name(\u0026self) -\u003e \u0026str;\n\n    async fn handle(\u0026self, call: MethodCall) -\u003e Result\u003cserde_json::Value, RmcpError\u003e;\n}\n\n/// MethodCall structure\npub struct MethodCall {\n    pub id: String,\n    pub method: String,\n    pub params: serde_json::Value,\n}\n\nimpl MethodCall {\n    pub fn parse_params\u003cT: serde::de::DeserializeOwned\u003e(\u0026self) -\u003e Result\u003cT, RmcpError\u003e {\n        serde_json::from_value(self.params.clone())\n            .map_err(|e| RmcpError::ParseError(e.to_string()))\n    }\n}\n\n/// Error codes for MCP protocol\n#[derive(Debug, Clone, Copy)]\npub enum RmcpErrorCode {\n    /// -32600: Invalid request\n    InvalidRequest,\n    /// -32601: Method not found\n    MethodNotFound,\n    /// -32602: Invalid params\n    InvalidParams,\n    /// -32603: Internal error\n    InternalError,\n    /// -32000: Server error\n    ServerError,\n    /// -32001: Not found\n    NotFound,\n    /// -32002: Conflict\n    Conflict,\n}\n\nimpl RmcpErrorCode {\n    /// Get the numeric code for this error\n    pub fn code(\u0026self) -\u003e i32 {\n        match self {\n            Self::InvalidRequest =\u003e -32600,\n            Self::MethodNotFound =\u003e -32601,\n            Self::InvalidParams =\u003e -32602,\n            Self::InternalError =\u003e -32603,\n            Self::ServerError =\u003e -32000,\n            Self::NotFound =\u003e -32001,\n            Self::Conflict =\u003e -32002,\n        }\n    }\n\n    /// Get a string representation of this error code\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::InvalidRequest =\u003e \"Invalid request\",\n            Self::MethodNotFound =\u003e \"Method not found\",\n            Self::InvalidParams =\u003e \"Invalid params\",\n            Self::InternalError =\u003e \"Internal error\",\n            Self::ServerError =\u003e \"Server error\",\n            Self::NotFound =\u003e \"Not found\",\n            Self::Conflict =\u003e \"Conflict\",\n        }\n    }\n}\n\n/// Enhanced MCP error type\n#[derive(Debug)]\npub enum RmcpError {\n    /// Parse error when deserializing request\n    ParseError(String),\n    /// Error from the repository layer\n    RepositoryError(String),\n    /// Other errors\n    Other(String),\n}\n\nimpl fmt::Display for RmcpError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::ParseError(msg) =\u003e write!(f, \"Parse error: {}\", msg),\n            Self::RepositoryError(msg) =\u003e write!(f, \"Repository error: {}\", msg),\n            Self::Other(msg) =\u003e write!(f, \"Error: {}\", msg),\n        }\n    }\n}\n\nimpl StdError for RmcpError {}\n\nimpl RmcpError {\n    /// Get the error code for this error\n    pub fn error_code(\u0026self) -\u003e RmcpErrorCode {\n        match self {\n            Self::ParseError(_) =\u003e RmcpErrorCode::InvalidParams,\n            Self::RepositoryError(_) =\u003e RmcpErrorCode::ServerError,\n            Self::Other(_) =\u003e RmcpErrorCode::InternalError,\n        }\n    }\n\n    /// Convert to a JSON-RPC error response\n    pub fn to_jsonrpc_error(\u0026self, id: \u0026str) -\u003e serde_json::Value {\n        let code = self.error_code();\n        serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": id,\n            \"error\": {\n                \"code\": code.code(),\n                \"message\": code.as_str(),\n                \"data\": self.to_string()\n            }\n        })\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for RmcpError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        RmcpError::ParseError(err.to_string())\n    }\n}\n\nimpl From\u003cRepositoryError\u003e for RmcpError {\n    fn from(err: RepositoryError) -\u003e Self {\n        match err {\n            RepositoryError::NotFound(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Not found: {}\", msg))\n            }\n            RepositoryError::Conflict(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Conflict: {}\", msg))\n            }\n            RepositoryError::Internal(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Internal: {}\", msg))\n            }\n            RepositoryError::Validation(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Validation: {}\", msg))\n            }\n        }\n    }\n}\n\n/// MCP handler for get_symbols method\npub struct GetSymbolsHandler {\n    // Repository for fetching symbols\n    symbol_repository: Arc\u003cdyn SymbolRepository\u003e,\n}\n\nimpl GetSymbolsHandler {\n    /// Create a new handler with the provided repository\n    pub fn new(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e Self {\n        GetSymbolsHandler { symbol_repository }\n    }\n\n    /// Convert a domain Symbol to a DTO for the API\n    fn to_dto(symbol: \u0026Symbol) -\u003e SymbolDTO {\n        SymbolDTO {\n            id: symbol.id.clone(),\n            name: symbol.name.clone(),\n            category: symbol.category.clone(),\n            description: symbol.description.clone(),\n            related_symbols: symbol.related_symbols.clone(),\n        }\n    }\n}\n\n#[async_trait]\nimpl Handler for GetSymbolsHandler {\n    /// The method name this handler responds to\n    fn method_name(\u0026self) -\u003e \u0026str {\n        \"get_symbols\"\n    }\n\n    /// Handle the MCP method call\n    async fn handle(\u0026self, call: MethodCall) -\u003e Result\u003cserde_json::Value, RmcpError\u003e {\n        let params: GetSymbolsParams = call.parse_params()?;\n\n        // Fetch symbols from the repository\n        let symbols = match (params.category.as_deref(), params.query.as_deref()) {\n            // If we have a query, search for it\n            (_, Some(query)) =\u003e self.symbol_repository.search_symbols(query).await?,\n            // If we have just a category, filter by it\n            (Some(category), None) =\u003e self.symbol_repository.list_symbols(Some(category)).await?,\n            // No filters, list all symbols\n            (None, None) =\u003e self.symbol_repository.list_symbols(None).await?,\n        };\n\n        // Apply limit\n        let symbols = symbols\n            .iter()\n            .take(params.limit)\n            .map(|s| Self::to_dto(s))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let total_count = symbols.len();\n\n        Ok(serde_json::to_value(GetSymbolsResponse {\n            symbols,\n            total_count,\n        })?)\n    }\n}\n\n/// Factory function to create the get_symbols handler with provided repository\npub fn get_symbols(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e GetSymbolsHandler {\n    GetSymbolsHandler::new(symbol_repository)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n    use serde_json::json;\n\n    #[tokio::test]\n    async fn test_get_symbols_handler() {\n        // Create a real repository with test data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        let handler = GetSymbolsHandler::new(repository);\n\n        // Create a method call with empty params\n        let call = MethodCall {\n            id: \"test-call\".to_string(),\n            method: \"get_symbols\".to_string(),\n            params: json!({}),\n        };\n\n        let result = handler.handle(call).await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n\n        // Validate response structure\n        assert!(response.is_object());\n        assert!(response.as_object().unwrap().contains_key(\"symbols\"));\n        assert!(response.as_object().unwrap().contains_key(\"total_count\"));\n\n        // We should have some symbols from the test data\n        assert!(response[\"total_count\"].as_u64().unwrap() \u003e 0);\n    }\n\n    #[test]\n    fn test_method_name() {\n        let factory = MemoryRepositoryFactory::new();\n        let repository = factory.create_symbol_repository();\n\n        let handler = GetSymbolsHandler::new(repository);\n        assert_eq!(handler.method_name(), \"get_symbols\");\n    }\n\n    #[test]\n    fn test_error_codes() {\n        let error = RmcpError::ParseError(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32602); // InvalidParams\n\n        let error = RmcpError::RepositoryError(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32000); // ServerError\n\n        let error = RmcpError::Other(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32603); // InternalError\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":20}},{"line":167,"address":[],"length":0,"stats":{"Line":20}},{"line":168,"address":[],"length":0,"stats":{"Line":20}},{"line":169,"address":[],"length":0,"stats":{"Line":20}},{"line":170,"address":[],"length":0,"stats":{"Line":20}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":5}},{"line":185,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":20}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}}],"covered":29,"coverable":76},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","methods","mod.rs"],"content":"// Exports the method modules\npub mod get_symbols;\npub use get_symbols::get_symbols;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","mod.rs"],"content":"pub mod methods;\npub mod schema;\n\n// We're not using the get_symbols function for now\n// pub use methods::get_symbols;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","schema.rs"],"content":"use rmcp::schemars;\nuse serde::{Deserialize, Serialize};\n\n/// Parameters for the get_symbols MCP method\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct GetSymbolsParams {\n    /// Category filter (dream, mythological, etc.)\n    pub category: Option\u003cString\u003e,\n\n    /// Search query for symbol names or descriptions\n    pub query: Option\u003cString\u003e,\n\n    /// Maximum number of symbols to return\n    #[serde(default = \"default_limit\")]\n    pub limit: usize,\n}\n\nfn default_limit() -\u003e usize {\n    50\n}\n\n/// Response for the get_symbols MCP method\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct GetSymbolsResponse {\n    /// List of symbols matching the query\n    pub symbols: Vec\u003cSymbolDTO\u003e,\n\n    /// Total count of symbols matching the query (for pagination)\n    pub total_count: usize,\n}\n\n/// Data transfer object for Symbol, used in MCP responses\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct SymbolDTO {\n    /// Unique identifier for the symbol\n    pub id: String,\n\n    /// Name of the symbol\n    pub name: String,\n\n    /// Category of the symbol\n    pub category: String,\n\n    /// Brief description of the symbol\n    pub description: String,\n\n    /// Related symbol IDs\n    pub related_symbols: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::{self, json};\n\n    #[test]\n    fn test_get_symbols_params_serialization() {\n        let params = GetSymbolsParams {\n            category: Some(\"dream\".to_string()),\n            query: Some(\"water\".to_string()),\n            limit: 10,\n        };\n\n        let json = serde_json::to_value(params).unwrap();\n\n        assert_eq!(json[\"category\"], \"dream\");\n        assert_eq!(json[\"query\"], \"water\");\n        assert_eq!(json[\"limit\"], 10);\n    }\n\n    #[test]\n    fn test_get_symbols_params_default_limit() {\n        let params = GetSymbolsParams {\n            category: None,\n            query: None,\n            limit: default_limit(),\n        };\n\n        assert_eq!(params.limit, 50);\n    }\n\n    #[test]\n    fn test_symbol_dto_serialization() {\n        let symbol = SymbolDTO {\n            id: \"water\".to_string(),\n            name: \"Water\".to_string(),\n            category: \"dream\".to_string(),\n            description: \"Symbolizes emotions\".to_string(),\n            related_symbols: vec![\"ocean\".to_string(), \"river\".to_string()],\n        };\n\n        let json = serde_json::to_value(symbol).unwrap();\n\n        assert_eq!(json[\"id\"], \"water\");\n        assert_eq!(json[\"name\"], \"Water\");\n        assert_eq!(json[\"category\"], \"dream\");\n        assert_eq!(json[\"description\"], \"Symbolizes emotions\");\n        assert_eq!(json[\"related_symbols\"][0], \"ocean\");\n        assert_eq!(json[\"related_symbols\"][1], \"river\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":7}},{"line":19,"address":[],"length":0,"stats":{"Line":7}}],"covered":2,"coverable":2},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","utils","mod.rs"],"content":"// Utility functions for the application\npub fn version() -\u003e \u0026'static str {\n    env!(\"CARGO_PKG_VERSION\")\n}\n\n// Error handling utilities will be added here\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":0}},{"line":3,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","api","handlers_tests.rs"],"content":"use std::sync::Arc;\n\nuse axum::{Json, extract::State, http::StatusCode};\n\n// We need to import directly from the crate\nuse dream_ontology_mcp::domain::RepositoryFactory;\nuse dream_ontology_mcp::domain::SymbolRepository;\nuse dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n// Add a dependency on the correct modules instead of using API modules\n#[tokio::test]\nasync fn test_list_symbols_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // For now, we won't test the API directly, but just verify repository works\n    let symbols = repository.list_symbols(None).await.unwrap();\n\n    // Validate response\n    assert!(!symbols.is_empty());\n}\n\n#[tokio::test]\nasync fn test_get_symbol_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Get the first symbol from the repo to test with\n    let symbols = repository.list_symbols(None).await.unwrap();\n    let first_symbol = symbols.first().unwrap();\n\n    // Test direct repository call\n    let result = repository.get_symbol(\u0026first_symbol.id).await;\n\n    // Validate response\n    assert!(result.is_ok());\n    let symbol = result.unwrap();\n    assert_eq!(symbol.id, first_symbol.id);\n}\n\n#[tokio::test]\nasync fn test_search_symbols_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Get the first symbol from the repo to test with\n    let symbols = repository.list_symbols(None).await.unwrap();\n    let first_symbol = symbols.first().unwrap();\n\n    // Search symbols using query from the first symbol (should find it)\n    let query = \u0026first_symbol.name[0..3]; // Use first few characters of name\n    let search_results = repository.search_symbols(query).await.unwrap();\n\n    // Validate response\n    assert!(!search_results.is_empty());\n    assert!(search_results.iter().any(|s| s.id == first_symbol.id));\n}\n\n#[tokio::test]\nasync fn test_error_handling_symbol_not_found() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Call repository with nonexistent ID\n    let result = repository.get_symbol(\"nonexistent-id\").await;\n\n    // Validate error response\n    assert!(result.is_err());\n    match result {\n        Err(err) =\u003e {\n            let error_string = err.to_string();\n            assert!(error_string.contains(\"Not found\"));\n        }\n        _ =\u003e panic!(\"Expected error response\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","api","mod.rs"],"content":"// API test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// API integration tests\npub mod handlers_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","fixtures.rs"],"content":"use dream_ontology_mcp::domain::{Symbol, SymbolSet};\n\n/// Create a test symbol with basic properties\npub fn create_test_symbol(id: \u0026str, name: \u0026str, category: \u0026str) -\u003e Symbol {\n    Symbol::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        format!(\"Description for {}\", name),\n    )\n}\n\n/// Create a test symbol with additional properties\npub fn create_detailed_symbol(\n    id: \u0026str,\n    name: \u0026str,\n    category: \u0026str,\n    description: \u0026str,\n    interpretations: Vec\u003c(\u0026str, \u0026str)\u003e,\n    related_symbols: Vec\u003c\u0026str\u003e,\n) -\u003e Symbol {\n    let mut symbol = Symbol::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        description.to_string(),\n    );\n\n    // Add interpretations\n    for (context, interpretation) in interpretations {\n        symbol.add_interpretation(context.to_string(), interpretation.to_string());\n    }\n\n    // Add related symbols\n    for related in related_symbols {\n        symbol.add_related_symbol(related.to_string());\n    }\n\n    symbol\n}\n\n/// Create a test symbol set with sample symbols\npub fn create_test_symbol_set(\n    id: \u0026str,\n    name: \u0026str,\n    category: \u0026str,\n    description: \u0026str,\n) -\u003e SymbolSet {\n    let mut symbol_set = SymbolSet::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        description.to_string(),\n    );\n\n    // Add some sample symbols\n    symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n    symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n    symbol_set.add_symbol(create_test_symbol(\"mountain\", \"Mountain\", \"dream\"));\n\n    symbol_set\n}\n\n/// Create a populated dream symbols set\npub fn create_dream_symbols() -\u003e SymbolSet {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols appearing in dreams\".to_string(),\n    );\n\n    // Water symbol with interpretations\n    let water = create_detailed_symbol(\n        \"water\",\n        \"Water\",\n        \"dream\",\n        \"Symbolizes emotions and the unconscious\",\n        vec![\n            (\n                \"psychology\",\n                \"Represents the depths of the unconscious mind\",\n            ),\n            (\"spiritual\", \"Symbol of purification and renewal\"),\n        ],\n        vec![\"ocean\", \"river\"],\n    );\n\n    // Fire symbol with interpretations\n    let fire = create_detailed_symbol(\n        \"fire\",\n        \"Fire\",\n        \"dream\",\n        \"Symbolizes transformation and passion\",\n        vec![\n            (\"psychology\", \"Represents energy, desire or anger\"),\n            (\"spiritual\", \"Symbol of enlightenment and purification\"),\n        ],\n        vec![\"light\", \"sun\"],\n    );\n\n    // Add symbols to the set\n    symbol_set.add_symbol(water);\n    symbol_set.add_symbol(fire);\n\n    symbol_set\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","mock_repository.rs"],"content":"use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\n\nuse dream_ontology_mcp::domain::{\n    RepositoryError, RepositoryFactory, RepositoryResult, Symbol, SymbolRepository, SymbolSet,\n    SymbolSetRepository,\n};\n\nuse super::fixtures;\n\n/// Mock repository that allows customizing behavior for tests\npub struct MockSymbolRepository {\n    symbols: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n    fail_next_operation: Arc\u003cRwLock\u003cOption\u003cRepositoryError\u003e\u003e\u003e,\n}\n\nimpl MockSymbolRepository {\n    pub fn new() -\u003e Self {\n        MockSymbolRepository {\n            symbols: Arc::new(RwLock::new(HashMap::new())),\n            fail_next_operation: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        let test_symbols = vec![\n            fixtures::create_test_symbol(\"water\", \"Water\", \"dream\"),\n            fixtures::create_test_symbol(\"fire\", \"Fire\", \"dream\"),\n            fixtures::create_test_symbol(\"mountain\", \"Mountain\", \"dream\"),\n        ];\n\n        let mut symbols_map = HashMap::new();\n        for symbol in test_symbols {\n            symbols_map.insert(symbol.id.clone(), symbol);\n        }\n        *self.symbols.write().unwrap() = symbols_map;\n        self\n    }\n\n    /// Makes the next repository operation fail with the specified error\n    pub fn fail_next(\u0026self, error: RepositoryError) {\n        *self.fail_next_operation.write().unwrap() = Some(error);\n    }\n\n    /// Helper to check and consume the next failure if one is set\n    fn check_failure(\u0026self) -\u003e Result\u003c(), RepositoryError\u003e {\n        let mut fail_guard = self.fail_next_operation.write().unwrap();\n        if let Some(err) = fail_guard.take() {\n            return Err(err);\n        }\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl SymbolRepository for MockSymbolRepository {\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        symbols\n            .get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found\",\n                id\n            )))\n    }\n\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        let symbols: Vec\u003cSymbol\u003e = match category {\n            Some(cat) =\u003e symbols\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e symbols.values().cloned().collect(),\n        };\n\n        Ok(symbols)\n    }\n\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        let query = query.to_lowercase();\n\n        let results: Vec\u003cSymbol\u003e = symbols\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(results)\n    }\n\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"Symbol with ID {} already exists\",\n                symbol.id\n            )));\n        }\n\n        let symbol_clone = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n        Ok(symbol_clone)\n    }\n\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if !symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found for update\",\n                symbol.id\n            )));\n        }\n\n        let symbol_clone = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n        Ok(symbol_clone)\n    }\n\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if !symbols.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found for deletion\",\n                id\n            )));\n        }\n\n        symbols.remove(id);\n        Ok(())\n    }\n}\n\n/// Mock SymbolSet repository for testing\npub struct MockSymbolSetRepository {\n    symbol_sets: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n    fail_next_operation: Arc\u003cRwLock\u003cOption\u003cRepositoryError\u003e\u003e\u003e,\n}\n\nimpl MockSymbolSetRepository {\n    pub fn new() -\u003e Self {\n        MockSymbolSetRepository {\n            symbol_sets: Arc::new(RwLock::new(HashMap::new())),\n            fail_next_operation: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        let test_sets = vec![\n            fixtures::create_test_symbol_set(\n                \"dream-symbols\",\n                \"Dream Symbols\",\n                \"dream\",\n                \"Common symbols in dreams\",\n            ),\n            fixtures::create_test_symbol_set(\n                \"myth-symbols\",\n                \"Mythological Symbols\",\n                \"mythological\",\n                \"Symbols from mythology\",\n            ),\n        ];\n\n        let mut sets_map = HashMap::new();\n        for set in test_sets {\n            sets_map.insert(set.id.clone(), set);\n        }\n        *self.symbol_sets.write().unwrap() = sets_map;\n        self\n    }\n\n    /// Makes the next repository operation fail with the specified error\n    pub fn fail_next(\u0026self, error: RepositoryError) {\n        *self.fail_next_operation.write().unwrap() = Some(error);\n    }\n\n    /// Helper to check and consume the next failure if one is set\n    fn check_failure(\u0026self) -\u003e Result\u003c(), RepositoryError\u003e {\n        let mut fail_guard = self.fail_next_operation.write().unwrap();\n        if let Some(err) = fail_guard.take() {\n            return Err(err);\n        }\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl SymbolSetRepository for MockSymbolSetRepository {\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        sets.get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found\",\n                id\n            )))\n    }\n\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        let sets: Vec\u003cSymbolSet\u003e = match category {\n            Some(cat) =\u003e sets\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e sets.values().cloned().collect(),\n        };\n\n        Ok(sets)\n    }\n\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        let query = query.to_lowercase();\n\n        let results: Vec\u003cSymbolSet\u003e = sets\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(results)\n    }\n\n    async fn create_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if sets.contains_key(\u0026symbol_set.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"SymbolSet with ID {} already exists\",\n                symbol_set.id\n            )));\n        }\n\n        let set_clone = symbol_set.clone();\n        sets.insert(symbol_set.id.clone(), symbol_set);\n        Ok(set_clone)\n    }\n\n    async fn update_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if !sets.contains_key(\u0026symbol_set.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found for update\",\n                symbol_set.id\n            )));\n        }\n\n        let set_clone = symbol_set.clone();\n        sets.insert(symbol_set.id.clone(), symbol_set);\n        Ok(set_clone)\n    }\n\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if !sets.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found for deletion\",\n                id\n            )));\n        }\n\n        sets.remove(id);\n        Ok(())\n    }\n}\n\n/// Mock repository factory for testing\npub struct MockRepositoryFactory {\n    symbol_repository: Arc\u003cMockSymbolRepository\u003e,\n    symbol_set_repository: Arc\u003cMockSymbolSetRepository\u003e,\n}\n\nimpl MockRepositoryFactory {\n    pub fn new() -\u003e Self {\n        MockRepositoryFactory {\n            symbol_repository: Arc::new(MockSymbolRepository::new()),\n            symbol_set_repository: Arc::new(MockSymbolSetRepository::new()),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        // Create new instances with test data\n        let symbol_repo = MockSymbolRepository::new().with_test_data();\n        let symbol_set_repo = MockSymbolSetRepository::new().with_test_data();\n\n        MockRepositoryFactory {\n            symbol_repository: Arc::new(symbol_repo),\n            symbol_set_repository: Arc::new(symbol_set_repo),\n        }\n    }\n}\n\nimpl RepositoryFactory for MockRepositoryFactory {\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e {\n        self.symbol_repository.clone()\n    }\n\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e {\n        self.symbol_set_repository.clone()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","mod.rs"],"content":"pub mod fixtures;\npub mod mock_repository;\n\n/// Initialize test environment\npub fn setup() {\n    // Initialize any common test setup here\n    // For example, tracing setup for tests\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","mod.rs"],"content":"pub mod symbol_tests;\npub mod symbolset_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","symbol_tests.rs"],"content":"use dream_ontology_mcp::domain::Symbol;\n\n#[test]\nfn test_symbol_creation() {\n    let symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    assert_eq!(symbol.id, \"water\");\n    assert_eq!(symbol.name, \"Water\");\n    assert_eq!(symbol.category, \"dream\");\n    assert_eq!(symbol.description, \"Symbol of the unconscious\");\n    assert!(symbol.related_symbols.is_empty());\n    assert!(symbol.interpretations.is_empty());\n}\n\n#[test]\nfn test_symbol_interpretations() {\n    let mut symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    symbol.add_interpretation(\n        \"psychological\".to_string(),\n        \"Represents emotions and the unconscious mind\".to_string(),\n    );\n    symbol.add_interpretation(\n        \"spiritual\".to_string(),\n        \"Symbol of purification and renewal\".to_string(),\n    );\n\n    assert_eq!(symbol.interpretations.len(), 2);\n    assert_eq!(\n        symbol.interpretations.get(\"psychological\").unwrap(),\n        \"Represents emotions and the unconscious mind\"\n    );\n    assert_eq!(\n        symbol.interpretations.get(\"spiritual\").unwrap(),\n        \"Symbol of purification and renewal\"\n    );\n}\n\n#[test]\nfn test_symbol_related_symbols() {\n    let mut symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    symbol.add_related_symbol(\"ocean\".to_string());\n    symbol.add_related_symbol(\"river\".to_string());\n    symbol.add_related_symbol(\"lake\".to_string());\n\n    assert_eq!(symbol.related_symbols.len(), 3);\n    assert!(symbol.related_symbols.contains(\u0026\"ocean\".to_string()));\n    assert!(symbol.related_symbols.contains(\u0026\"river\".to_string()));\n    assert!(symbol.related_symbols.contains(\u0026\"lake\".to_string()));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","symbolset_tests.rs"],"content":"use crate::common::fixtures;\nuse dream_ontology_mcp::domain::SymbolSet;\n\n#[test]\nfn test_symbolset_creation() {\n    let symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    assert_eq!(symbol_set.id, \"dream-symbols\");\n    assert_eq!(symbol_set.name, \"Dream Symbols\");\n    assert_eq!(symbol_set.category, \"dream\");\n    assert_eq!(symbol_set.description, \"Common symbols in dreams\");\n    assert_eq!(symbol_set.count(), 0);\n}\n\n#[test]\nfn test_symbolset_add_get_symbol() {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    // Add a test symbol\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n    symbol_set.add_symbol(symbol);\n\n    // Verify the symbol was added\n    assert_eq!(symbol_set.count(), 1);\n\n    // Retrieve and check the symbol\n    let retrieved = symbol_set.get_symbol(\"water\");\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().name, \"Water\");\n}\n\n#[test]\nfn test_symbolset_remove_symbol() {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    // Add a test symbol\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n    symbol_set.add_symbol(symbol);\n    assert_eq!(symbol_set.count(), 1);\n\n    // Remove the symbol\n    let removed = symbol_set.remove_symbol(\"water\");\n    assert!(removed.is_some());\n    assert_eq!(removed.unwrap().id, \"water\");\n\n    // Verify it was removed\n    assert_eq!(symbol_set.count(), 0);\n    assert!(symbol_set.get_symbol(\"water\").is_none());\n}\n\n#[test]\nfn test_symbolset_search() {\n    let symbol_set =\n        fixtures::create_test_symbol_set(\"test-set\", \"Test Set\", \"test\", \"Test symbol set\");\n\n    // Search for symbols containing \"water\"\n    let results = symbol_set.search(\"water\");\n    assert_eq!(results.len(), 1);\n    assert_eq!(results[0].id, \"water\");\n\n    // Search for symbols containing \"mountain\"\n    let results = symbol_set.search(\"mountain\");\n    assert_eq!(results.len(), 1);\n    assert_eq!(results[0].id, \"mountain\");\n\n    // Search with no matches\n    let results = symbol_set.search(\"xyz\");\n    assert_eq!(results.len(), 0);\n}\n\n#[test]\nfn test_symbolset_filter_by_category() {\n    let mut symbol_set = SymbolSet::new(\n        \"mixed-symbols\".to_string(),\n        \"Mixed Symbols\".to_string(),\n        \"mixed\".to_string(),\n        \"Mixed category symbols\".to_string(),\n    );\n\n    // Add symbols with different categories\n    symbol_set.add_symbol(fixtures::create_test_symbol(\"water\", \"Water\", \"dream\"));\n    symbol_set.add_symbol(fixtures::create_test_symbol(\n        \"dragon\",\n        \"Dragon\",\n        \"mythological\",\n    ));\n    symbol_set.add_symbol(fixtures::create_test_symbol(\"tree\", \"Tree\", \"dream\"));\n\n    // Filter by dream category\n    let dream_symbols = symbol_set.filter_by_category(\"dream\");\n    assert_eq!(dream_symbols.len(), 2);\n\n    // Filter by mythological category\n    let myth_symbols = symbol_set.filter_by_category(\"mythological\");\n    assert_eq!(myth_symbols.len(), 1);\n    assert_eq!(myth_symbols[0].id, \"dragon\");\n\n    // Filter by non-existent category\n    let empty_result = symbol_set.filter_by_category(\"nonexistent\");\n    assert_eq!(empty_result.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","lib.rs"],"content":"// This file serves as the main entry point for integration tests\n// It re-exports all test modules for organization\n\npub mod api;\npub mod common;\npub mod domain;\npub mod llm;\npub mod mcp;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","client_tests.rs"],"content":"use dream_ontology_mcp::llm::client::LlmClient;\n\n#[test]\nfn test_llm_client_creation() {\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n    let _default_client = LlmClient::with_default_model(\"test-api-key\".to_string());\n\n    // No assertions needed, we're just verifying the client can be created\n}\n\n#[tokio::test]\nasync fn test_llm_client_generate() {\n    // This is a placeholder test that would need mocking to properly test\n    // For now, we're just ensuring the method signatures are correct\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n\n    // This test would be enhanced with mocking in the future\n    // We're just testing that the code compiles for now\n}\n\n#[tokio::test]\nasync fn test_llm_client_chat() {\n    // This is a placeholder test that would need mocking to properly test\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n\n    // This test would be enhanced with mocking in the future\n    // We're just testing that the code compiles for now\n}\n\n#[test]\nfn test_message_struct() {\n    use dream_ontology_mcp::llm::client::Message;\n\n    let message = Message {\n        role: \"user\".to_string(),\n        content: \"test content\".to_string(),\n    };\n\n    assert_eq!(message.role, \"user\");\n    assert_eq!(message.content, \"test content\");\n}\n\n#[test]\nfn test_completion_request_serialization() {\n    use dream_ontology_mcp::llm::client::{CompletionRequest, Message};\n    use serde_json::Value;\n\n    let request = CompletionRequest {\n        model: \"test-model\".to_string(),\n        messages: vec![\n            Message {\n                role: \"system\".to_string(),\n                content: \"You are a helpful assistant\".to_string(),\n            },\n            Message {\n                role: \"user\".to_string(),\n                content: \"Hello\".to_string(),\n            },\n        ],\n        temperature: Some(0.7),\n        max_tokens: Some(100),\n    };\n\n    let json = serde_json::to_value(request).unwrap();\n\n    assert_eq!(json[\"model\"], \"test-model\");\n    assert_eq!(json[\"messages\"][0][\"role\"], \"system\");\n    assert_eq!(\n        json[\"messages\"][0][\"content\"],\n        \"You are a helpful assistant\"\n    );\n    assert_eq!(json[\"messages\"][1][\"role\"], \"user\");\n    assert_eq!(json[\"messages\"][1][\"content\"], \"Hello\");\n\n    // For floating-point comparisons, check that the value exists and is approximately correct\n    assert!(json[\"temperature\"].is_number());\n    if let Value::Number(temp) = \u0026json[\"temperature\"] {\n        let temp_f64 = temp.as_f64().unwrap();\n        assert!((temp_f64 - 0.7).abs() \u003c 0.001);\n    }\n\n    assert_eq!(json[\"max_tokens\"], 100);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","mod.rs"],"content":"// LLM test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// These modules are commented out because we've removed the LLM functionality\n// as it belongs to the Dream Interpretation Backend, not the Symbolic Ontology Database\n// pub mod client_tests;\n// pub mod prompts_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","prompts_tests.rs"],"content":"use crate::common::fixtures;\nuse dream_ontology_mcp::llm::prompts::{build_symbol_prompt, build_system_prompt};\n\n#[test]\nfn test_build_system_prompt() {\n    let prompt = build_system_prompt(\"dream\");\n    assert!(prompt.contains(\"dream symbolism\"));\n\n    let prompt = build_system_prompt(\"mythological\");\n    assert!(prompt.contains(\"mythological symbolism\"));\n}\n\n#[test]\nfn test_build_symbol_prompt_basic() {\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n\n    // Test with no context or query\n    let basic_prompt = build_symbol_prompt(\u0026symbol, None, None);\n    assert!(basic_prompt.contains(\"Water\"));\n    assert!(basic_prompt.contains(\"Description for Water\"));\n    assert!(basic_prompt.contains(\"Consider general interpretive contexts\"));\n    assert!(basic_prompt.contains(\"Provide a general interpretation\"));\n}\n\n#[test]\nfn test_build_symbol_prompt_detailed() {\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n\n    // Test with context and query\n    let detailed_prompt = build_symbol_prompt(\n        \u0026symbol,\n        Some(\"recurring nightmares\"),\n        Some(\"Why does this symbol appear during times of stress?\"),\n    );\n\n    assert!(detailed_prompt.contains(\"Consider the specific context: recurring nightmares\"));\n    assert!(detailed_prompt.contains(\n        \"Specifically address this question: Why does this symbol appear during times of stress?\"\n    ));\n}\n\n#[test]\nfn test_build_symbol_prompt_structure() {\n    let symbol = fixtures::create_detailed_symbol(\n        \"fire\",\n        \"Fire\",\n        \"dream\",\n        \"Symbol of transformation and passion\",\n        vec![\n            (\"psychology\", \"Represents energy, desire or anger\"),\n            (\"spiritual\", \"Symbol of enlightenment and purification\"),\n        ],\n        vec![\"light\", \"sun\"],\n    );\n\n    let prompt = build_symbol_prompt(\u0026symbol, None, None);\n\n    // Check for structured format sections\n    assert!(prompt.contains(\"Core symbolic meaning\"));\n    assert!(prompt.contains(\"Psychological significance\"));\n    assert!(prompt.contains(\"Cultural and historical context\"));\n    assert!(prompt.contains(\"Practical implications\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","mcp","get_symbols_tests.rs"],"content":"use dream_ontology_mcp::domain::RepositoryFactory;\nuse dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\nuse dream_ontology_mcp::mcp::methods::get_symbols::{GetSymbolsHandler, Handler, MethodCall};\nuse serde_json::json;\n\n#[tokio::test]\nasync fn test_get_symbols_handler_name() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    assert_eq!(handler.method_name(), \"get_symbols\");\n}\n\n#[tokio::test]\nasync fn test_get_symbols_empty_params() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({}),\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Basic validation that we get a successful response with an array of symbols\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n    assert!(result.get(\"symbols\").unwrap().is_array());\n}\n\n#[tokio::test]\nasync fn test_get_symbols_with_category() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({ \"category\": \"nature\" }), // Using a category we know exists in test data\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Validate we get results filtered by category\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n\n    let symbols = result.get(\"symbols\").unwrap().as_array().unwrap();\n    // If we got any symbols, they should have the right category\n    if !symbols.is_empty() {\n        for symbol in symbols {\n            assert_eq!(symbol.get(\"category\").unwrap().as_str().unwrap(), \"nature\");\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_get_symbols_with_search() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({ \"query\": \"light\" }), // Using \"query\" parameter as defined in schema\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Just verify we get a response - test data might not have \"light\" references\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","mcp","mod.rs"],"content":"// MCP test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// MCP test modules\npub mod get_symbols_tests;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","error.rs"],"content":"use axum::{\n    Json,\n    http::StatusCode,\n    response::{IntoResponse, Response},\n};\nuse serde_json::json;\nuse std::fmt;\n\nuse crate::domain::RepositoryError;\n\n/// API Error types that can be returned by handlers\n#[derive(Debug)]\npub enum ApiError {\n    /// Entity not found (404)\n    NotFound(String),\n    /// Bad request (400)\n    BadRequest(String),\n    /// Conflict (409)\n    Conflict(String),\n    /// Internal server error (500)\n    Internal(String),\n    /// Unauthorized (401)\n    Unauthorized(String),\n    /// Forbidden (403)\n    Forbidden(String),\n}\n\nimpl fmt::Display for ApiError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let message = match self {\n            ApiError::NotFound(msg) =\u003e format!(\"Not found: {}\", msg),\n            ApiError::BadRequest(msg) =\u003e format!(\"Bad request: {}\", msg),\n            ApiError::Conflict(msg) =\u003e format!(\"Conflict: {}\", msg),\n            ApiError::Internal(msg) =\u003e format!(\"Internal error: {}\", msg),\n            ApiError::Unauthorized(msg) =\u003e format!(\"Unauthorized: {}\", msg),\n            ApiError::Forbidden(msg) =\u003e format!(\"Forbidden: {}\", msg),\n        };\n        write!(f, \"{}\", message)\n    }\n}\n\n/// Transform ApiError into an HTTP response\nimpl IntoResponse for ApiError {\n    fn into_response(self) -\u003e Response {\n        let (status, message) = match \u0026self {\n            ApiError::NotFound(msg) =\u003e (StatusCode::NOT_FOUND, msg),\n            ApiError::BadRequest(msg) =\u003e (StatusCode::BAD_REQUEST, msg),\n            ApiError::Conflict(msg) =\u003e (StatusCode::CONFLICT, msg),\n            ApiError::Internal(msg) =\u003e (StatusCode::INTERNAL_SERVER_ERROR, msg),\n            ApiError::Unauthorized(msg) =\u003e (StatusCode::UNAUTHORIZED, msg),\n            ApiError::Forbidden(msg) =\u003e (StatusCode::FORBIDDEN, msg),\n        };\n\n        // Create a JSON response body with error details\n        let body = Json(json!({\n            \"error\": {\n                \"type\": status.canonical_reason(),\n                \"message\": message,\n            }\n        }));\n\n        // Combine the status code and body\n        (status, body).into_response()\n    }\n}\n\n/// Shorthand for API result type\npub type ApiResult\u003cT\u003e = Result\u003cT, ApiError\u003e;\n\n/// Convert from domain RepositoryError to API error\nimpl From\u003cRepositoryError\u003e for ApiError {\n    fn from(err: RepositoryError) -\u003e Self {\n        match err {\n            RepositoryError::NotFound(msg) =\u003e ApiError::NotFound(msg),\n            RepositoryError::Conflict(msg) =\u003e ApiError::Conflict(msg),\n            RepositoryError::Validation(msg) =\u003e ApiError::BadRequest(msg),\n            RepositoryError::Internal(msg) =\u003e ApiError::Internal(msg),\n        }\n    }\n}\n\n/// Maps from RMCP errors to API errors\nimpl From\u003ccrate::mcp::methods::get_symbols::RmcpError\u003e for ApiError {\n    fn from(err: crate::mcp::methods::get_symbols::RmcpError) -\u003e Self {\n        use crate::mcp::methods::get_symbols::{RmcpError, RmcpErrorCode};\n\n        match err {\n            RmcpError::ParseError(msg) =\u003e ApiError::BadRequest(msg),\n            RmcpError::RepositoryError(msg) =\u003e {\n                // For repository errors, we can determine the type based on message content\n                // since we don't have direct access to original RepositoryError\n                if msg.starts_with(\"Not found:\") {\n                    ApiError::NotFound(msg)\n                } else if msg.starts_with(\"Conflict:\") {\n                    ApiError::Conflict(msg)\n                } else if msg.starts_with(\"Validation:\") {\n                    ApiError::BadRequest(msg)\n                } else {\n                    ApiError::Internal(msg)\n                }\n            }\n            RmcpError::Other(msg) =\u003e ApiError::Internal(msg),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_api_error_display() {\n        let error = ApiError::NotFound(\"user\".to_string());\n        assert_eq!(error.to_string(), \"Not found: user\");\n    }\n\n    #[test]\n    fn test_repository_error_conversion() {\n        let repo_error = RepositoryError::NotFound(\"Symbol not found\".to_string());\n        let api_error = ApiError::from(repo_error);\n\n        match api_error {\n            ApiError::NotFound(msg) =\u003e assert_eq!(msg, \"Symbol not found\"),\n            _ =\u003e panic!(\"Conversion produced wrong error type\"),\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":7,"coverable":40},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","handlers.rs"],"content":"use axum::{\n    Json,\n    extract::{Path, State},\n};\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\n\nuse super::error::{ApiError, ApiResult};\nuse crate::domain::{Symbol, SymbolRepository};\n\n/// Health check handler\npub async fn health_check() -\u003e \u0026'static str {\n    \"Dream Ontology MCP API is healthy\"\n}\n\n/// Represents a collection of symbols in a response\n#[derive(Serialize)]\npub struct SymbolsResponse {\n    pub symbols: Vec\u003cSymbol\u003e,\n    pub total_count: usize,\n}\n\n/// Query parameters for listing symbols\n#[derive(Deserialize)]\npub struct ListSymbolsQuery {\n    pub category: Option\u003cString\u003e,\n    pub query: Option\u003cString\u003e,\n    #[serde(default = \"default_limit\")]\n    pub limit: usize,\n}\n\n/// Default limit for symbol queries\nfn default_limit() -\u003e usize {\n    50 // Default to 50 symbols\n}\n\n/// List all symbols with optional filtering\npub async fn list_symbols(\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n    Json(params): Json\u003cListSymbolsQuery\u003e,\n) -\u003e ApiResult\u003cJson\u003cSymbolsResponse\u003e\u003e {\n    // Validate input parameters\n    if let Some(ref query) = params.query {\n        if query.trim().is_empty() {\n            return Err(ApiError::BadRequest(\n                \"Search query cannot be empty\".to_string(),\n            ));\n        }\n    }\n\n    if let Some(ref category) = params.category {\n        if category.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Category cannot be empty\".to_string()));\n        }\n    }\n\n    // Determine which repository method to call based on parameters\n    let symbols = match (params.category.as_deref(), params.query.as_deref()) {\n        (_, Some(query)) =\u003e repository.search_symbols(query).await?,\n        (Some(category), None) =\u003e repository.list_symbols(Some(category)).await?,\n        (None, None) =\u003e repository.list_symbols(None).await?,\n    };\n\n    // Apply limit and count\n    let total_count = symbols.len();\n    let symbols = symbols.into_iter().take(params.limit).collect();\n\n    Ok(Json(SymbolsResponse {\n        symbols,\n        total_count,\n    }))\n}\n\n/// Get a specific symbol by ID\npub async fn get_symbol(\n    Path(id): Path\u003cString\u003e,\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n) -\u003e ApiResult\u003cJson\u003cSymbol\u003e\u003e {\n    // Validate ID\n    if id.trim().is_empty() {\n        return Err(ApiError::BadRequest(\n            \"Symbol ID cannot be empty\".to_string(),\n        ));\n    }\n\n    // Retrieve the symbol from repository\n    let symbol = repository.get_symbol(\u0026id).await?;\n    Ok(Json(symbol))\n}\n\n/// Request body for symbol interpretation\n#[derive(Deserialize)]\npub struct InterpretRequest {\n    pub symbol_id: String,\n    pub context: Option\u003cString\u003e,\n    pub query: Option\u003cString\u003e,\n}\n\n/// Response for symbol interpretation\n#[derive(Serialize)]\npub struct InterpretResponse {\n    pub symbol_id: String,\n    pub context: Option\u003cString\u003e,\n    pub interpretation: String,\n}\n\n/// Validate an interpretation request\nfn validate_interpret_request(request: \u0026InterpretRequest) -\u003e Result\u003c(), ApiError\u003e {\n    if request.symbol_id.trim().is_empty() {\n        return Err(ApiError::BadRequest(\n            \"Symbol ID cannot be empty\".to_string(),\n        ));\n    }\n\n    // If context is provided, it shouldn't be empty\n    if let Some(ref context) = request.context {\n        if context.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Context cannot be empty\".to_string()));\n        }\n    }\n\n    // If query is provided, it shouldn't be empty\n    if let Some(ref query) = request.query {\n        if query.trim().is_empty() {\n            return Err(ApiError::BadRequest(\"Query cannot be empty\".to_string()));\n        }\n    }\n\n    Ok(())\n}\n\n/// Interpret a symbol\npub async fn interpret_symbol(\n    State(repository): State\u003cArc\u003cdyn SymbolRepository\u003e\u003e,\n    Json(request): Json\u003cInterpretRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cInterpretResponse\u003e\u003e {\n    // Validate request\n    validate_interpret_request(\u0026request)?;\n\n    // Check if symbol exists\n    let symbol = repository.get_symbol(\u0026request.symbol_id).await?;\n\n    // For now, we just return a placeholder interpretation\n    // In the future, this would use the LLM client to generate the interpretation\n    let interpretation = format!(\n        \"Interpretation of symbol '{}' with {} and {}.\",\n        symbol.name,\n        request.context.as_deref().unwrap_or(\"no context\"),\n        request.query.as_deref().unwrap_or(\"no query\")\n    );\n\n    Ok(Json(InterpretResponse {\n        symbol_id: request.symbol_id,\n        context: request.context,\n        interpretation,\n    }))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::RepositoryFactory;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let response = health_check().await;\n        assert_eq!(response, \"Dream Ontology MCP API is healthy\");\n    }\n\n    #[tokio::test]\n    async fn test_get_symbol_success() {\n        // Create test repository with data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        // Get the first symbol from the repo to test with\n        let symbols = repository.list_symbols(None).await.unwrap();\n        let first_symbol = symbols.first().unwrap();\n\n        // Test the handler\n        let path = Path(first_symbol.id.clone());\n        let result = get_symbol(path, State(repository)).await;\n\n        assert!(result.is_ok());\n        let symbol = result.unwrap().0; // Extract from Json wrapper\n        assert_eq!(symbol.id, first_symbol.id);\n    }\n\n    #[tokio::test]\n    async fn test_list_symbols() {\n        // Create test repository with data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        // Test with empty params (list all)\n        let params = ListSymbolsQuery {\n            category: None,\n            query: None,\n            limit: 10,\n        };\n\n        let result = list_symbols(State(repository.clone()), Json(params)).await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap().0; // Extract from Json wrapper\n        assert!(!response.symbols.is_empty());\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":40},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","mod.rs"],"content":"pub mod error;\npub mod handlers;\npub mod routes;\n\n// Re-export main router\npub use routes::router;\n// Re-export errors\npub use error::{ApiError, ApiResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","api","routes.rs"],"content":"use axum::{\n    Router,\n    extract::State,\n    routing::{get, post},\n};\nuse std::sync::Arc;\n\nuse super::handlers;\nuse crate::domain::SymbolRepository;\n\n/// Builds the main application router with all API routes\npub fn router(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e Router {\n    Router::new()\n        .route(\"/health\", get(handlers::health_check))\n        .route(\"/symbols\", get(handlers::list_symbols))\n        .route(\"/symbols/{id}\", get(handlers::get_symbol))\n        .route(\"/interpret\", post(handlers::interpret_symbol))\n        .with_state(symbol_repository)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::RepositoryFactory;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n    #[test]\n    fn test_router_creation() {\n        let factory = MemoryRepositoryFactory::new();\n        let repository = factory.create_symbol_repository();\n\n        let _router = router(repository);\n        // Just testing that it builds - actual routes tested in integration tests\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","config.rs"],"content":"use std::env;\nuse std::net::SocketAddr;\nuse std::str::FromStr;\n\n/// Configuration for the application, loaded from environment variables\n#[derive(Debug, Clone)]\npub struct Config {\n    /// Address to bind the HTTP server to (default: 127.0.0.1:3000)\n    pub server_addr: SocketAddr,\n    /// Log level (default: info)\n    pub log_level: String,\n    /// Whether to use in-memory repository (default: true)\n    pub use_memory_repository: bool,\n}\n\nimpl Default for Config {\n    fn default() -\u003e Self {\n        Self {\n            server_addr: SocketAddr::from(([127, 0, 0, 1], 3000)),\n            log_level: \"info\".to_string(),\n            use_memory_repository: true,\n        }\n    }\n}\n\nimpl Config {\n    /// Load configuration from environment variables\n    pub fn from_env() -\u003e Self {\n        let server_addr = env::var(\"SERVER_ADDR\")\n            .ok()\n            .and_then(|addr| SocketAddr::from_str(\u0026addr).ok())\n            .unwrap_or_else(|| SocketAddr::from(([127, 0, 0, 1], 3000)));\n\n        let log_level = env::var(\"LOG_LEVEL\").unwrap_or_else(|_| \"info\".to_string());\n\n        let use_memory_repository = env::var(\"USE_MEMORY_REPOSITORY\")\n            .map(|val| val.to_lowercase() == \"true\" || val == \"1\")\n            .unwrap_or(true);\n\n        Self {\n            server_addr,\n            log_level,\n            use_memory_repository,\n        }\n    }\n\n    /// Get the tracing filter based on the log level\n    pub fn get_tracing_filter(\u0026self) -\u003e String {\n        format!(\n            \"dream_ontology_mcp={},tower_http={}\",\n            self.log_level, self.log_level\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.server_addr.to_string(), \"127.0.0.1:3000\");\n        assert_eq!(config.log_level, \"info\");\n        assert!(config.use_memory_repository);\n    }\n\n    #[test]\n    fn test_get_tracing_filter() {\n        let config = Config {\n            log_level: \"debug\".to_string(),\n            ..Config::default()\n        };\n        assert_eq!(\n            config.get_tracing_filter(),\n            \"dream_ontology_mcp=debug,tower_http=debug\"\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":2}},{"line":20,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}}],"covered":6,"coverable":13},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","mod.rs"],"content":"/*!\n * # Domain Module\n *\n * The domain module contains the core business logic and models for the symbolic reasoning engine.\n * This includes:\n *\n * - **Symbol**: Represents a symbolic entity with interpretations and relationships\n * - **SymbolSet**: A collection of related symbols organized into an ontology\n * - **Repository**: Interfaces for persistence and data access\n *\n * The domain layer is designed to be persistence-agnostic, with implementations\n * provided in the infrastructure layer.\n */\n\n// Domain module exports\npub mod ontology;\npub mod repository;\npub mod symbols;\n\n// Re-exports for convenient access\npub use ontology::SymbolSet;\npub use repository::{\n    RepositoryError, RepositoryFactory, RepositoryResult, SymbolRepository, SymbolSetRepository,\n};\npub use symbols::Symbol;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","ontology.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\n\nuse super::symbols::Symbol;\n\n/// Represents a collection of symbols organized into an ontology\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SymbolSet {\n    /// Unique identifier for the symbol set\n    pub id: String,\n\n    /// Name of the symbol set\n    pub name: String,\n\n    /// Description of the symbol set\n    pub description: String,\n\n    /// Category of the symbol set (e.g., \"dream\", \"mythological\")\n    pub category: String,\n\n    /// Symbols contained in this set, indexed by ID\n    #[serde(default)]\n    pub symbols: HashMap\u003cString, Symbol\u003e,\n}\n\nimpl SymbolSet {\n    /// Create a new empty symbol set\n    pub fn new(id: String, name: String, category: String, description: String) -\u003e Self {\n        SymbolSet {\n            id,\n            name,\n            category,\n            description,\n            symbols: HashMap::new(),\n        }\n    }\n\n    /// Create a new symbol set with initial symbols\n    pub fn with_symbols(mut self, symbol_ids: Vec\u003c\u0026str\u003e) -\u003e Self {\n        // Note: This just stores empty placeholders - typically you'd populate\n        // with real symbols later through the repository\n        for id in symbol_ids {\n            self.symbols.insert(\n                id.to_string(),\n                Symbol::new(\n                    id.to_string(),\n                    id.to_string(), // Using ID as name for placeholder\n                    \"\".to_string(), // Empty category\n                    \"\".to_string(), // Empty description\n                ),\n            );\n        }\n        self\n    }\n\n    /// Add a symbol to the set\n    pub fn add_symbol(\u0026mut self, symbol: Symbol) -\u003e Option\u003cSymbol\u003e {\n        self.symbols.insert(symbol.id.clone(), symbol)\n    }\n\n    /// Get a symbol by ID\n    pub fn get_symbol(\u0026self, id: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(id)\n    }\n\n    /// Remove a symbol by ID\n    pub fn remove_symbol(\u0026mut self, id: \u0026str) -\u003e Option\u003cSymbol\u003e {\n        self.symbols.remove(id)\n    }\n\n    /// Search for symbols matching a query in name or description\n    pub fn search(\u0026self, query: \u0026str) -\u003e Vec\u003c\u0026Symbol\u003e {\n        let query = query.to_lowercase();\n        self.symbols\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .collect()\n    }\n\n    /// Filter symbols by category\n    pub fn filter_by_category(\u0026self, category: \u0026str) -\u003e Vec\u003c\u0026Symbol\u003e {\n        self.symbols\n            .values()\n            .filter(|s| s.category == category)\n            .collect()\n    }\n\n    /// Get all unique categories in this symbol set\n    pub fn get_categories(\u0026self) -\u003e HashSet\u003c\u0026str\u003e {\n        self.symbols.values().map(|s| s.category.as_str()).collect()\n    }\n\n    /// Count the symbols in this set\n    pub fn count(\u0026self) -\u003e usize {\n        self.symbols.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_symbol(id: \u0026str, name: \u0026str, category: \u0026str) -\u003e Symbol {\n        Symbol::new(\n            id.to_string(),\n            name.to_string(),\n            category.to_string(),\n            format!(\"Description for {}\", name),\n        )\n    }\n\n    #[test]\n    fn test_symbolset_creation() {\n        let symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        assert_eq!(symbol_set.id, \"dream-symbols\");\n        assert_eq!(symbol_set.name, \"Dream Symbols\");\n        assert_eq!(symbol_set.description, \"Common symbols appearing in dreams\");\n        assert_eq!(symbol_set.count(), 0);\n    }\n\n    #[test]\n    fn test_add_and_get_symbol() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        let water = create_test_symbol(\"water\", \"Water\", \"dream\");\n        let fire = create_test_symbol(\"fire\", \"Fire\", \"dream\");\n\n        symbol_set.add_symbol(water);\n        symbol_set.add_symbol(fire);\n\n        assert_eq!(symbol_set.count(), 2);\n\n        let retrieved = symbol_set.get_symbol(\"water\").unwrap();\n        assert_eq!(retrieved.name, \"Water\");\n\n        // Test replacing a symbol\n        let new_water = create_test_symbol(\"water\", \"Water (Updated)\", \"dream\");\n        symbol_set.add_symbol(new_water);\n\n        // Should still have 2 symbols\n        assert_eq!(symbol_set.count(), 2);\n\n        // But the water symbol should be updated\n        let updated = symbol_set.get_symbol(\"water\").unwrap();\n        assert_eq!(updated.name, \"Water (Updated)\");\n    }\n\n    #[test]\n    fn test_remove_symbol() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n\n        assert_eq!(symbol_set.count(), 2);\n\n        let removed = symbol_set.remove_symbol(\"water\").unwrap();\n        assert_eq!(removed.name, \"Water\");\n        assert_eq!(symbol_set.count(), 1);\n        assert!(symbol_set.get_symbol(\"water\").is_none());\n    }\n\n    #[test]\n    fn test_search() {\n        let mut symbol_set = SymbolSet::new(\n            \"dream-symbols\".to_string(),\n            \"Dream Symbols\".to_string(),\n            \"dream\".to_string(),\n            \"Common symbols appearing in dreams\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"ocean\", \"Ocean\", \"dream\"));\n\n        let results = symbol_set.search(\"wat\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"water\");\n\n        // Search is case-insensitive\n        let results = symbol_set.search(\"WATER\");\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"water\");\n    }\n\n    #[test]\n    fn test_filter_by_category() {\n        let mut symbol_set = SymbolSet::new(\n            \"mixed-symbols\".to_string(),\n            \"Mixed Symbols\".to_string(),\n            \"mixed\".to_string(),\n            \"Mixed symbol categories\".to_string(),\n        );\n\n        symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n        symbol_set.add_symbol(create_test_symbol(\"dragon\", \"Dragon\", \"mythological\"));\n        symbol_set.add_symbol(create_test_symbol(\"phoenix\", \"Phoenix\", \"mythological\"));\n\n        let dream_symbols = symbol_set.filter_by_category(\"dream\");\n        assert_eq!(dream_symbols.len(), 2);\n\n        let myth_symbols = symbol_set.filter_by_category(\"mythological\");\n        assert_eq!(myth_symbols.len(), 2);\n\n        // Check empty result for non-existent category\n        let empty = symbol_set.filter_by_category(\"nonexistent\");\n        assert_eq!(empty.len(), 0);\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":39}},{"line":34,"address":[],"length":0,"stats":{"Line":39}},{"line":39,"address":[],"length":0,"stats":{"Line":24}},{"line":42,"address":[],"length":0,"stats":{"Line":276}},{"line":43,"address":[],"length":0,"stats":{"Line":84}},{"line":44,"address":[],"length":0,"stats":{"Line":84}},{"line":45,"address":[],"length":0,"stats":{"Line":84}},{"line":46,"address":[],"length":0,"stats":{"Line":84}},{"line":47,"address":[],"length":0,"stats":{"Line":84}},{"line":48,"address":[],"length":0,"stats":{"Line":84}},{"line":49,"address":[],"length":0,"stats":{"Line":84}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":57,"address":[],"length":0,"stats":{"Line":32}},{"line":58,"address":[],"length":0,"stats":{"Line":32}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":7}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":28}},{"line":77,"address":[],"length":0,"stats":{"Line":21}},{"line":78,"address":[],"length":0,"stats":{"Line":15}},{"line":84,"address":[],"length":0,"stats":{"Line":9}},{"line":85,"address":[],"length":0,"stats":{"Line":9}},{"line":87,"address":[],"length":0,"stats":{"Line":51}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":14}},{"line":98,"address":[],"length":0,"stats":{"Line":14}}],"covered":29,"coverable":31},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","repository.rs"],"content":"use crate::domain::{Symbol, SymbolSet};\nuse async_trait::async_trait;\nuse std::error::Error;\nuse std::fmt::{Display, Formatter};\nuse std::sync::Arc;\n\n/// Domain-specific error type for repository operations\n#[derive(Debug)]\npub enum RepositoryError {\n    /// Entity not found\n    NotFound(String),\n    /// Conflict with existing entity\n    Conflict(String),\n    /// Internal repository error\n    Internal(String),\n    /// Validation error\n    Validation(String),\n}\n\nimpl Display for RepositoryError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::NotFound(msg) =\u003e write!(f, \"Not found: {}\", msg),\n            Self::Conflict(msg) =\u003e write!(f, \"Conflict: {}\", msg),\n            Self::Internal(msg) =\u003e write!(f, \"Internal error: {}\", msg),\n            Self::Validation(msg) =\u003e write!(f, \"Validation error: {}\", msg),\n        }\n    }\n}\n\nimpl Error for RepositoryError {}\n\npub type RepositoryResult\u003cT\u003e = Result\u003cT, RepositoryError\u003e;\n\n/// Repository trait for Symbol entities\n#[async_trait]\npub trait SymbolRepository: Send + Sync {\n    /// Get a symbol by its ID\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// List all symbols, optionally filtering by category\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e;\n\n    /// Search for symbols containing the query in name or description\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e;\n\n    /// Create a new symbol\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// Update an existing symbol\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e;\n\n    /// Delete a symbol by its ID\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e;\n}\n\n/// Repository trait for SymbolSet entities\n#[async_trait]\npub trait SymbolSetRepository: Send + Sync {\n    /// Get a symbol set by its ID\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// List all symbol sets, optionally filtering by category\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e;\n\n    /// Search for symbol sets containing the query in name or description\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e;\n\n    /// Create a new symbol set\n    async fn create_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// Update an existing symbol set\n    async fn update_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e;\n\n    /// Delete a symbol set by its ID\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e;\n}\n\n/// Factory for creating repository instances\npub trait RepositoryFactory {\n    /// Create a new symbol repository\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e;\n\n    /// Create a new symbol set repository\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e;\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":6},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","domain","symbols.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Represents a symbolic entity with its properties and interpretations\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Symbol {\n    /// Unique identifier for the symbol\n    pub id: String,\n\n    /// Name of the symbol\n    pub name: String,\n\n    /// Primary category (dream, mythological, archetypal, etc.)\n    pub category: String,\n\n    /// Brief description of the symbol\n    pub description: String,\n\n    /// Detailed interpretations across different contexts\n    pub interpretations: HashMap\u003cString, String\u003e,\n\n    /// Related symbols (by ID)\n    pub related_symbols: Vec\u003cString\u003e,\n\n    /// Additional properties as key-value pairs\n    #[serde(default)]\n    pub properties: HashMap\u003cString, String\u003e,\n}\n\nimpl Symbol {\n    /// Create a new symbol with minimal fields\n    pub fn new(id: String, name: String, category: String, description: String) -\u003e Self {\n        Symbol {\n            id,\n            name,\n            category,\n            description,\n            interpretations: HashMap::new(),\n            related_symbols: Vec::new(),\n            properties: HashMap::new(),\n        }\n    }\n\n    /// Set or update the category\n    pub fn with_category(mut self, category: \u0026str) -\u003e Self {\n        self.category = category.to_string();\n        self\n    }\n\n    /// Add related symbols\n    pub fn with_related(mut self, related: Vec\u003c\u0026str\u003e) -\u003e Self {\n        self.related_symbols = related.into_iter().map(|s| s.to_string()).collect();\n        self\n    }\n\n    /// Add an interpretation for a specific context\n    pub fn add_interpretation(\u0026mut self, context: String, interpretation: String) {\n        self.interpretations.insert(context, interpretation);\n    }\n\n    /// Add a related symbol by ID\n    pub fn add_related_symbol(\u0026mut self, symbol_id: String) {\n        if !self.related_symbols.contains(\u0026symbol_id) {\n            self.related_symbols.push(symbol_id);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_symbol_creation() {\n        let symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        assert_eq!(symbol.id, \"water\");\n        assert_eq!(symbol.name, \"Water\");\n        assert_eq!(symbol.category, \"dream\");\n        assert_eq!(\n            symbol.description,\n            \"Symbolizes emotions and the unconscious\"\n        );\n        assert!(symbol.interpretations.is_empty());\n        assert!(symbol.related_symbols.is_empty());\n    }\n\n    #[test]\n    fn test_add_interpretation() {\n        let mut symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        symbol.add_interpretation(\n            \"psychology\".to_string(),\n            \"Represents the depths of the unconscious mind\".to_string(),\n        );\n\n        assert_eq!(\n            symbol.interpretations.get(\"psychology\").unwrap(),\n            \"Represents the depths of the unconscious mind\"\n        );\n    }\n\n    #[test]\n    fn test_add_related_symbol() {\n        let mut symbol = Symbol::new(\n            \"water\".to_string(),\n            \"Water\".to_string(),\n            \"dream\".to_string(),\n            \"Symbolizes emotions and the unconscious\".to_string(),\n        );\n\n        symbol.add_related_symbol(\"ocean\".to_string());\n        symbol.add_related_symbol(\"river\".to_string());\n        // Adding duplicate should not add it again\n        symbol.add_related_symbol(\"ocean\".to_string());\n\n        assert_eq!(symbol.related_symbols.len(), 2);\n        assert!(symbol.related_symbols.contains(\u0026\"ocean\".to_string()));\n        assert!(symbol.related_symbols.contains(\u0026\"river\".to_string()));\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":185}},{"line":38,"address":[],"length":0,"stats":{"Line":185}},{"line":39,"address":[],"length":0,"stats":{"Line":185}},{"line":40,"address":[],"length":0,"stats":{"Line":185}},{"line":45,"address":[],"length":0,"stats":{"Line":60}},{"line":46,"address":[],"length":0,"stats":{"Line":60}},{"line":47,"address":[],"length":0,"stats":{"Line":60}},{"line":51,"address":[],"length":0,"stats":{"Line":60}},{"line":52,"address":[],"length":0,"stats":{"Line":240}},{"line":53,"address":[],"length":0,"stats":{"Line":60}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":9}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":7}}],"covered":15,"coverable":15},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","infrastructure","memory_repository.rs"],"content":"use crate::domain::{\n    RepositoryError, RepositoryFactory, RepositoryResult, Symbol, SymbolRepository, SymbolSet,\n    SymbolSetRepository,\n};\nuse async_trait;\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex, RwLock};\n\n/// Generic repository trait for basic CRUD operations\npub trait Repository\u003cK, V\u003e {\n    /// Get an item by its key\n    fn get(\u0026self, key: \u0026K) -\u003e Result\u003cOption\u003cV\u003e, RepositoryError\u003e;\n\n    /// Save an item with the given key\n    fn save(\u0026self, key: K, value: V) -\u003e Result\u003c(), RepositoryError\u003e;\n\n    /// Delete an item by its key, returns true if item was deleted\n    fn delete(\u0026self, key: \u0026K) -\u003e Result\u003cbool, RepositoryError\u003e;\n\n    /// List all items as key-value pairs\n    fn list(\u0026self) -\u003e Result\u003cVec\u003c(K, V)\u003e, RepositoryError\u003e;\n}\n\n/// In-memory implementation of the repositories for testing and development\n#[derive(Default, Clone)]\npub struct MemoryRepositoryFactory {\n    symbols: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n    symbol_sets: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n}\n\nimpl MemoryRepositoryFactory {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        // Load test data\n        let test_symbols = vec![\n            Symbol::new(\n                \"sun\".to_string(),\n                \"Sun\".to_string(),\n                \"nature\".to_string(),\n                \"Celestial body at the center of our solar system\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"light\", \"day\"]),\n            Symbol::new(\n                \"moon\".to_string(),\n                \"Moon\".to_string(),\n                \"nature\".to_string(),\n                \"Natural satellite of Earth\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"night\", \"tide\"]),\n            Symbol::new(\n                \"light\".to_string(),\n                \"Light\".to_string(),\n                \"concept\".to_string(),\n                \"Electromagnetic radiation visible to the human eye\".to_string(),\n            )\n            .with_category(\"concept\")\n            .with_related(vec![\"sun\", \"illumination\"]),\n            Symbol::new(\n                \"dark\".to_string(),\n                \"Darkness\".to_string(),\n                \"concept\".to_string(),\n                \"Absence of light\".to_string(),\n            )\n            .with_category(\"concept\")\n            .with_related(vec![\"night\", \"shadow\"]),\n            Symbol::new(\n                \"tree\".to_string(),\n                \"Tree\".to_string(),\n                \"nature\".to_string(),\n                \"Perennial plant with an elongated stem and branches\".to_string(),\n            )\n            .with_category(\"nature\")\n            .with_related(vec![\"forest\", \"wood\"]),\n        ];\n\n        let test_sets = vec![\n            SymbolSet::new(\n                \"celestial\".to_string(),\n                \"Celestial Bodies\".to_string(),\n                \"nature\".to_string(),\n                \"Celestial bodies and phenomena\".to_string(),\n            )\n            .with_symbols(vec![\"sun\", \"moon\", \"star\"]),\n            SymbolSet::new(\n                \"opposites\".to_string(),\n                \"Opposing Concepts\".to_string(),\n                \"concept\".to_string(),\n                \"Paired opposing concepts\".to_string(),\n            )\n            .with_symbols(vec![\"light\", \"dark\", \"day\", \"night\"]),\n        ];\n\n        // Insert test data\n        {\n            let mut symbols = self.symbols.write().unwrap();\n            for symbol in test_symbols {\n                symbols.insert(symbol.id.clone(), symbol);\n            }\n\n            let mut symbol_sets = self.symbol_sets.write().unwrap();\n            for set in test_sets {\n                symbol_sets.insert(set.id.clone(), set);\n            }\n        }\n\n        self\n    }\n}\n\nimpl RepositoryFactory for MemoryRepositoryFactory {\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e {\n        Arc::new(MemorySymbolRepository {\n            data: Arc::clone(\u0026self.symbols),\n        })\n    }\n\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e {\n        Arc::new(MemorySymbolSetRepository {\n            data: Arc::clone(\u0026self.symbol_sets),\n        })\n    }\n}\n\n/// In-memory implementation of SymbolRepository\nstruct MemorySymbolRepository {\n    data: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n}\n\n#[async_trait::async_trait]\nimpl SymbolRepository for MemorySymbolRepository {\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let symbols = self.data.read().unwrap();\n        symbols\n            .get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                id\n            )))\n    }\n\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        let symbols = self.data.read().unwrap();\n        let result = match category {\n            Some(cat) =\u003e symbols\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e symbols.values().cloned().collect(),\n        };\n        Ok(result)\n    }\n\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        let symbols = self.data.read().unwrap();\n        let query = query.to_lowercase();\n\n        let result = symbols\n            .values()\n            .filter(|s| {\n                s.id.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(result)\n    }\n\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol already exists\n        if symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"Symbol already exists: {}\",\n                symbol.id\n            )));\n        }\n\n        // Insert the new symbol\n        let result = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n\n        Ok(result)\n    }\n\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol exists\n        if !symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                symbol.id\n            )));\n        }\n\n        // Update the symbol\n        let result = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n\n        Ok(result)\n    }\n\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        let mut symbols = self.data.write().unwrap();\n\n        // Check if symbol exists\n        if !symbols.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol not found: {}\",\n                id\n            )));\n        }\n\n        // Remove the symbol\n        symbols.remove(id);\n\n        Ok(())\n    }\n}\n\n/// In-memory implementation of SymbolSetRepository\nstruct MemorySymbolSetRepository {\n    data: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n}\n\n#[async_trait::async_trait]\nimpl SymbolSetRepository for MemorySymbolSetRepository {\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let sets = self.data.read().unwrap();\n        sets.get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                id\n            )))\n    }\n\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        let sets = self.data.read().unwrap();\n        let result = match category {\n            Some(cat) =\u003e sets\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e sets.values().cloned().collect(),\n        };\n        Ok(result)\n    }\n\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        let sets = self.data.read().unwrap();\n        let query = query.to_lowercase();\n\n        let result = sets\n            .values()\n            .filter(|s| {\n                s.id.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(result)\n    }\n\n    async fn create_symbol_set(\u0026self, set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set already exists\n        if sets.contains_key(\u0026set.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"SymbolSet already exists: {}\",\n                set.id\n            )));\n        }\n\n        // Insert the new set\n        let result = set.clone();\n        sets.insert(set.id.clone(), set);\n\n        Ok(result)\n    }\n\n    async fn update_symbol_set(\u0026self, set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set exists\n        if !sets.contains_key(\u0026set.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                set.id\n            )));\n        }\n\n        // Update the set\n        let result = set.clone();\n        sets.insert(set.id.clone(), set);\n\n        Ok(result)\n    }\n\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        let mut sets = self.data.write().unwrap();\n\n        // Check if set exists\n        if !sets.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet not found: {}\",\n                id\n            )));\n        }\n\n        // Remove the set\n        sets.remove(id);\n\n        Ok(())\n    }\n}\n\n/// An in-memory implementation of the Repository trait.\n/// This is primarily useful for testing and prototyping.\npub struct MemoryRepository\u003cK, V\u003e {\n    data: Arc\u003cMutex\u003cHashMap\u003cK, V\u003e\u003e\u003e,\n}\n\nimpl\u003cK, V\u003e MemoryRepository\u003cK, V\u003e\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    /// Create a new empty memory repository\n    pub fn new() -\u003e Self {\n        Self {\n            data: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    /// Create a memory repository with initial data\n    pub fn with_data(initial_data: HashMap\u003cK, V\u003e) -\u003e Self {\n        Self {\n            data: Arc::new(Mutex::new(initial_data)),\n        }\n    }\n}\n\nimpl\u003cK, V\u003e Repository\u003cK, V\u003e for MemoryRepository\u003cK, V\u003e\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    fn get(\u0026self, key: \u0026K) -\u003e Result\u003cOption\u003cV\u003e, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(data) =\u003e Ok(data.get(key).cloned()),\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn save(\u0026self, key: K, value: V) -\u003e Result\u003c(), RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(mut data) =\u003e {\n                data.insert(key, value);\n                Ok(())\n            }\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn delete(\u0026self, key: \u0026K) -\u003e Result\u003cbool, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(mut data) =\u003e Ok(data.remove(key).is_some()),\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n\n    fn list(\u0026self) -\u003e Result\u003cVec\u003c(K, V)\u003e, RepositoryError\u003e {\n        match self.data.lock() {\n            Ok(data) =\u003e {\n                let items = data.iter().map(|(k, v)| (k.clone(), v.clone())).collect();\n                Ok(items)\n            }\n            Err(_) =\u003e Err(RepositoryError::Internal(\n                \"Failed to acquire lock\".to_string(),\n            )),\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":15}},{"line":33,"address":[],"length":0,"stats":{"Line":15}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":12}},{"line":41,"address":[],"length":0,"stats":{"Line":12}},{"line":42,"address":[],"length":0,"stats":{"Line":12}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":45,"address":[],"length":0,"stats":{"Line":12}},{"line":46,"address":[],"length":0,"stats":{"Line":12}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":12}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":12}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":12}},{"line":63,"address":[],"length":0,"stats":{"Line":12}},{"line":64,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":12}},{"line":67,"address":[],"length":0,"stats":{"Line":12}},{"line":69,"address":[],"length":0,"stats":{"Line":12}},{"line":70,"address":[],"length":0,"stats":{"Line":12}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":12}},{"line":81,"address":[],"length":0,"stats":{"Line":12}},{"line":82,"address":[],"length":0,"stats":{"Line":12}},{"line":83,"address":[],"length":0,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":12}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":12}},{"line":101,"address":[],"length":0,"stats":{"Line":192}},{"line":102,"address":[],"length":0,"stats":{"Line":60}},{"line":105,"address":[],"length":0,"stats":{"Line":12}},{"line":106,"address":[],"length":0,"stats":{"Line":84}},{"line":107,"address":[],"length":0,"stats":{"Line":24}},{"line":111,"address":[],"length":0,"stats":{"Line":12}},{"line":116,"address":[],"length":0,"stats":{"Line":15}},{"line":117,"address":[],"length":0,"stats":{"Line":15}},{"line":118,"address":[],"length":0,"stats":{"Line":15}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":139,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":147,"address":[],"length":0,"stats":{"Line":9}},{"line":148,"address":[],"length":0,"stats":{"Line":9}},{"line":149,"address":[],"length":0,"stats":{"Line":18}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":9}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":12}},{"line":167,"address":[],"length":0,"stats":{"Line":10}},{"line":168,"address":[],"length":0,"stats":{"Line":8}},{"line":173,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}}],"covered":84,"coverable":188},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","infrastructure","mod.rs"],"content":"/// Infrastructure layer for MCP\n/// Contains implementations of the domain interfaces\npub mod memory_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","lib.rs"],"content":"/*!\n * # Dream Ontology MCP Library\n *\n * This library implements a symbolic reasoning engine for dream interpretation\n * and symbolic analysis through the Model Context Protocol (MCP).\n *\n * ## Core Components\n *\n * - **Domain Models**: Define the core business objects like `Symbol` and `SymbolSet`\n * - **MCP Implementation**: Protocol-compliant methods for symbolic reasoning\n * - **Infrastructure**: Repository implementations and external integrations\n *\n * ## Usage Example\n *\n * ```rust\n * use dream_ontology_mcp::domain::{Symbol, SymbolRepository};\n * use dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\n *\n * // Create a repository with test data\n * let repo_factory = MemoryRepositoryFactory::new().with_test_data();\n * let symbol_repo = repo_factory.create_symbol_repository();\n *\n * // Use the repository asynchronously\n * async fn get_water_symbol(repo: Arc\u003cdyn SymbolRepository\u003e) -\u003e Option\u003cSymbol\u003e {\n *     repo.get(\"water\").await.ok()\n * }\n * ```\n */\n\n// Re-export all modules for better ergonomics\n\n/// Core domain models and business logic\npub mod domain;\n\n/// MCP protocol implementation for symbolic reasoning\npub mod mcp;\n\n/// Infrastructure implementations for repositories and external services\npub mod infrastructure;\n\n/// Utility functions and shared helpers\nmod utils;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","client.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::error::Error;\n\n/// A simple LLM client for interacting with OpenRouter\n#[derive(Debug, Clone)]\npub struct LlmClient {\n    api_key: String,\n    model: String,\n    base_url: String,\n}\n\n/// Request structure for LLM completions\n#[derive(Debug, Serialize)]\npub struct CompletionRequest {\n    pub model: String,\n    pub messages: Vec\u003cMessage\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub temperature: Option\u003cf32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_tokens: Option\u003cu32\u003e,\n}\n\n/// Message structure for LLM conversations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Message {\n    pub role: String,\n    pub content: String,\n}\n\n/// Response from LLM completion requests\n#[derive(Debug, Deserialize)]\npub struct CompletionResponse {\n    pub id: String,\n    pub choices: Vec\u003cChoice\u003e,\n}\n\n/// A single completion choice\n#[derive(Debug, Deserialize)]\npub struct Choice {\n    pub message: Message,\n    pub finish_reason: String,\n}\n\nimpl LlmClient {\n    /// Create a new LLM client\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        LlmClient {\n            api_key,\n            model,\n            base_url: \"https://openrouter.ai/api/v1\".to_string(),\n        }\n    }\n\n    /// Create a client with the default DeepSeek model\n    pub fn with_default_model(api_key: String) -\u003e Self {\n        Self::new(api_key, \"deepseek/deepseek-chat\".to_string())\n    }\n\n    /// Generate a completion for the given prompt\n    pub async fn generate(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n        // This is a stub implementation\n        // In a real implementation, we would make an HTTP request to the OpenRouter API\n\n        // For now, just return a mock response\n        Ok(format!(\"LLM response to: {}\", prompt))\n    }\n\n    /// Generate a completion with a system prompt and user message\n    pub async fn chat(\n        \u0026self,\n        system_prompt: \u0026str,\n        user_message: \u0026str,\n    ) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n        // This is just preparing the messages - we're not using them yet in this stub\n        let _messages = vec![\n            Message {\n                role: \"system\".to_string(),\n                content: system_prompt.to_string(),\n            },\n            Message {\n                role: \"user\".to_string(),\n                content: user_message.to_string(),\n            },\n        ];\n\n        // This is a stub implementation\n        Ok(format!(\n            \"LLM chat response to system: '{}' and user: '{}'\",\n            system_prompt, user_message\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_generate() {\n        let client = LlmClient::with_default_model(\"test-key\".to_string());\n        let result = client\n            .generate(\"What is the meaning of water in dreams?\")\n            .await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n        assert!(response.contains(\"LLM response to:\"));\n    }\n\n    #[tokio::test]\n    async fn test_chat() {\n        let client = LlmClient::with_default_model(\"test-key\".to_string());\n        let result = client\n            .chat(\n                \"You are a dream symbol interpreter\",\n                \"What does water represent in dreams?\",\n            )\n            .await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n        assert!(response.contains(\"LLM chat response\"));\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","mod.rs"],"content":"pub mod client;\npub mod prompts;\n\n// No re-exports for now as we're not using them directly yet\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","llm","prompts.rs"],"content":"use crate::domain::Symbol;\n\n/// Template for the system prompt when interpreting symbols\npub const SYSTEM_PROMPT: \u0026str = r#\"\nYou are an expert interpreter of symbolic content, specializing in {category} symbolism.\nYou provide insightful, nuanced interpretations based on established psychological and cultural frameworks.\nRespond with clear, thoughtful analysis without unnecessary disclaimers.\nBase your interpretations on established symbolic meanings and psychological principles.\n\"#;\n\n/// Builds a system prompt for a specific symbol category\npub fn build_system_prompt(category: \u0026str) -\u003e String {\n    SYSTEM_PROMPT.replace(\"{category}\", category)\n}\n\n/// Template for the user prompt when interpreting a specific symbol\npub const SYMBOL_PROMPT: \u0026str = r#\"\nInterpret the symbol \"{symbol_name}\" which is described as: {symbol_description}\n\n{context_instruction}\n\n{specific_query}\n\nProvide a structured interpretation that includes:\n1. Core symbolic meaning\n2. Psychological significance\n3. Cultural and historical context\n4. Practical implications\n\"#;\n\n/// Builds a user prompt for interpreting a symbol\npub fn build_symbol_prompt(symbol: \u0026Symbol, context: Option\u003c\u0026str\u003e, query: Option\u003c\u0026str\u003e) -\u003e String {\n    let context_instruction = match context {\n        Some(ctx) =\u003e format!(\"Consider the specific context: {}\", ctx),\n        None =\u003e \"Consider general interpretive contexts\".to_string(),\n    };\n\n    let specific_query = match query {\n        Some(q) =\u003e format!(\"Specifically address this question: {}\", q),\n        None =\u003e \"Provide a general interpretation\".to_string(),\n    };\n\n    SYMBOL_PROMPT\n        .replace(\"{symbol_name}\", \u0026symbol.name)\n        .replace(\"{symbol_description}\", \u0026symbol.description)\n        .replace(\"{context_instruction}\", \u0026context_instruction)\n        .replace(\"{specific_query}\", \u0026specific_query)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    fn create_test_symbol() -\u003e Symbol {\n        Symbol {\n            id: \"water\".to_string(),\n            name: \"Water\".to_string(),\n            category: \"dream\".to_string(),\n            description: \"Symbolizes emotions and the unconscious\".to_string(),\n            interpretations: HashMap::new(),\n            related_symbols: vec![\"ocean\".to_string()],\n            properties: HashMap::new(),\n        }\n    }\n\n    #[test]\n    fn test_build_system_prompt() {\n        let prompt = build_system_prompt(\"dream\");\n        assert!(prompt.contains(\"dream symbolism\"));\n    }\n\n    #[test]\n    fn test_build_symbol_prompt() {\n        let symbol = create_test_symbol();\n\n        // Test with no context or query\n        let basic_prompt = build_symbol_prompt(\u0026symbol, None, None);\n        assert!(basic_prompt.contains(\"Water\"));\n        assert!(basic_prompt.contains(\"Symbolizes emotions and the unconscious\"));\n        assert!(basic_prompt.contains(\"Consider general interpretive contexts\"));\n        assert!(basic_prompt.contains(\"Provide a general interpretation\"));\n\n        // Test with context and query\n        let detailed_prompt = build_symbol_prompt(\n            \u0026symbol,\n            Some(\"recurring nightmares\"),\n            Some(\"Why does this symbol appear during times of stress?\"),\n        );\n\n        assert!(detailed_prompt.contains(\"Consider the specific context: recurring nightmares\"));\n        assert!(detailed_prompt.contains(\"Specifically address this question: Why does this symbol appear during times of stress?\"));\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":1}},{"line":13,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":2}}],"covered":14,"coverable":14},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","logging.rs"],"content":"use axum::Router;\nuse axum::body::Body;\nuse axum::http::{Request, StatusCode};\nuse std::time::Duration;\nuse tower_http::classify::{ServerErrorsAsFailures, SharedClassifier};\nuse tower_http::trace::{self, TraceLayer};\nuse tracing::{Level, info, warn};\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\n\nuse crate::config::Config;\n\n/// Initialize the tracing subscriber based on the provided configuration\npub fn init_tracing(config: \u0026Config) {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| config.get_tracing_filter().into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n}\n\n/// Creates a trace layer for HTTP request and response logging.\n///\n/// This function returns a TraceLayer configured with custom behavior for logging\n/// HTTP requests and responses, with specific handling for different status codes.\n///\n/// # Returns\n///\n/// A configured `TraceLayer` middleware that can be added to an Axum router.\n///\n/// # Example\n///\n/// ```\n/// use axum::Router;\n/// use crate::logging::trace_layer;\n///\n/// let app = Router::new()\n///     .route(\"/\", get(|| async { \"Hello, World!\" }))\n///     .layer(trace_layer());\n/// ```\npub fn trace_layer() -\u003e TraceLayer\u003c\n    SharedClassifier\u003cServerErrorsAsFailures\u003e,\n    trace::DefaultMakeSpan,\n    impl Fn(\u0026Request\u003cBody\u003e, \u0026tracing::Span) + Copy,\n    impl Fn(\u0026axum::http::Response\u003cBody\u003e, Duration, \u0026tracing::Span) + Copy,\n\u003e {\n    tower_http::trace::TraceLayer::new_for_http()\n        .make_span_with(tower_http::trace::DefaultMakeSpan::new().level(Level::INFO))\n        .on_request(|request: \u0026Request\u003c_\u003e, _span: \u0026tracing::Span| {\n            info!(\n                \"Request: {} {} {:?}\",\n                request.method(),\n                request.uri(),\n                request.version()\n            );\n        })\n        .on_response(\n            |response: \u0026axum::http::Response\u003cBody\u003e, latency: Duration, _span: \u0026tracing::Span| {\n                let status = response.status();\n                let latency = format!(\"{:.3} ms\", latency.as_secs_f64() * 1000.0);\n\n                if status.is_success() {\n                    info!(\n                        \"Response: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                } else if status.is_server_error() {\n                    warn!(\n                        \"Server error: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                } else {\n                    info!(\n                        \"Non-success response: {} in {} - {}\",\n                        status.as_u16(),\n                        latency,\n                        status.canonical_reason().unwrap_or(\"Unknown\")\n                    );\n                }\n            },\n        )\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":34},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","main.rs"],"content":"use std::net::SocketAddr;\nuse std::sync::Arc;\n\nuse axum::serve;\nuse tokio::net::TcpListener;\nuse tracing::{debug, info};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\nuse crate::config::Config;\nuse crate::domain::RepositoryFactory;\nuse crate::infrastructure::memory_repository::MemoryRepositoryFactory;\nuse crate::logging::{init_tracing, trace_layer};\n\n/// API module containing HTTP endpoints and request handlers\nmod api;\n\n/// Configuration module for loading and managing application settings\nmod config;\n\n/// Domain module containing core business logic and models\nmod domain;\n\n/// Infrastructure module for external integrations and persistence\nmod infrastructure;\n\n// TODO: This module belongs to the Dream Interpretation Backend, not the Symbolic Ontology\n/// LLM integration module for language model interaction\nmod llm;\n\n/// Logging configuration and utilities\nmod logging;\n\n/// MCP implementation for protocol-compliant symbolic reasoning\nmod mcp;\n\n/// Utility functions and shared helpers\nmod utils;\n\n/// Main application entry point for the Dream Ontology Symbolic MCP Server.\n///\n/// This starts an Axum-based HTTP server that provides:\n/// 1. REST API endpoints for symbol and ontology management\n/// 2. MCP protocol endpoints for semantic reasoning\n///\n/// The server uses a repository pattern to abstract data access, with\n/// in-memory implementation available for development and testing.\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Load configuration from environment\n    let config = Config::from_env();\n\n    // Initialize tracing with config\n    init_tracing(\u0026config);\n\n    info!(\n        \"Starting Dream Ontology Symbolic MCP Server v{}\",\n        utils::version()\n    );\n\n    debug!(?config, \"Loaded configuration\");\n\n    // Initialize repositories based on configuration\n    let repo_factory = if config.use_memory_repository {\n        info!(\"Using in-memory repository with test data\");\n        MemoryRepositoryFactory::new().with_test_data()\n    } else {\n        // In the future, we could add other repository implementations here\n        info!(\"Using in-memory repository (default)\");\n        MemoryRepositoryFactory::new().with_test_data()\n    };\n\n    let symbol_repository = repo_factory.create_symbol_repository();\n\n    // Create the API router with repository dependency and logging middleware\n    let app = api::router(symbol_repository.clone()).layer(trace_layer());\n\n    // TODO: Initialize MCP server with method handlers\n    // using the same repository\n    debug!(\"API Server initialized with symbol repository and logging middleware\");\n\n    // Start HTTP server\n    info!(\"API Server listening on {}\", config.server_addr);\n\n    // Create a TCP listener and serve with Axum\n    let listener = TcpListener::bind(\u0026config.server_addr).await?;\n    axum::serve(listener, app.into_make_service()).await?;\n\n    info!(\"Server shutting down\");\n\n    Ok(())\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","methods","get_symbols.rs"],"content":"use async_trait::async_trait;\nuse serde_json;\nuse std::error::Error as StdError;\nuse std::fmt;\nuse std::sync::Arc;\n\nuse crate::domain::{RepositoryError, RepositoryFactory, Symbol, SymbolRepository};\nuse crate::mcp::schema::{GetSymbolsParams, GetSymbolsResponse, SymbolDTO};\n\n/// Handler trait definition\n#[async_trait]\npub trait Handler: Send + Sync {\n    fn method_name(\u0026self) -\u003e \u0026str;\n\n    async fn handle(\u0026self, call: MethodCall) -\u003e Result\u003cserde_json::Value, RmcpError\u003e;\n}\n\n/// MethodCall structure\npub struct MethodCall {\n    pub id: String,\n    pub method: String,\n    pub params: serde_json::Value,\n}\n\nimpl MethodCall {\n    pub fn parse_params\u003cT: serde::de::DeserializeOwned\u003e(\u0026self) -\u003e Result\u003cT, RmcpError\u003e {\n        serde_json::from_value(self.params.clone())\n            .map_err(|e| RmcpError::ParseError(e.to_string()))\n    }\n}\n\n/// Error codes for MCP protocol\n#[derive(Debug, Clone, Copy)]\npub enum RmcpErrorCode {\n    /// -32600: Invalid request\n    InvalidRequest,\n    /// -32601: Method not found\n    MethodNotFound,\n    /// -32602: Invalid params\n    InvalidParams,\n    /// -32603: Internal error\n    InternalError,\n    /// -32000: Server error\n    ServerError,\n    /// -32001: Not found\n    NotFound,\n    /// -32002: Conflict\n    Conflict,\n}\n\nimpl RmcpErrorCode {\n    /// Get the numeric code for this error\n    pub fn code(\u0026self) -\u003e i32 {\n        match self {\n            Self::InvalidRequest =\u003e -32600,\n            Self::MethodNotFound =\u003e -32601,\n            Self::InvalidParams =\u003e -32602,\n            Self::InternalError =\u003e -32603,\n            Self::ServerError =\u003e -32000,\n            Self::NotFound =\u003e -32001,\n            Self::Conflict =\u003e -32002,\n        }\n    }\n\n    /// Get a string representation of this error code\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::InvalidRequest =\u003e \"Invalid request\",\n            Self::MethodNotFound =\u003e \"Method not found\",\n            Self::InvalidParams =\u003e \"Invalid params\",\n            Self::InternalError =\u003e \"Internal error\",\n            Self::ServerError =\u003e \"Server error\",\n            Self::NotFound =\u003e \"Not found\",\n            Self::Conflict =\u003e \"Conflict\",\n        }\n    }\n}\n\n/// Enhanced MCP error type\n#[derive(Debug)]\npub enum RmcpError {\n    /// Parse error when deserializing request\n    ParseError(String),\n    /// Error from the repository layer\n    RepositoryError(String),\n    /// Other errors\n    Other(String),\n}\n\nimpl fmt::Display for RmcpError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Self::ParseError(msg) =\u003e write!(f, \"Parse error: {}\", msg),\n            Self::RepositoryError(msg) =\u003e write!(f, \"Repository error: {}\", msg),\n            Self::Other(msg) =\u003e write!(f, \"Error: {}\", msg),\n        }\n    }\n}\n\nimpl StdError for RmcpError {}\n\nimpl RmcpError {\n    /// Get the error code for this error\n    pub fn error_code(\u0026self) -\u003e RmcpErrorCode {\n        match self {\n            Self::ParseError(_) =\u003e RmcpErrorCode::InvalidParams,\n            Self::RepositoryError(_) =\u003e RmcpErrorCode::ServerError,\n            Self::Other(_) =\u003e RmcpErrorCode::InternalError,\n        }\n    }\n\n    /// Convert to a JSON-RPC error response\n    pub fn to_jsonrpc_error(\u0026self, id: \u0026str) -\u003e serde_json::Value {\n        let code = self.error_code();\n        serde_json::json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": id,\n            \"error\": {\n                \"code\": code.code(),\n                \"message\": code.as_str(),\n                \"data\": self.to_string()\n            }\n        })\n    }\n}\n\nimpl From\u003cserde_json::Error\u003e for RmcpError {\n    fn from(err: serde_json::Error) -\u003e Self {\n        RmcpError::ParseError(err.to_string())\n    }\n}\n\nimpl From\u003cRepositoryError\u003e for RmcpError {\n    fn from(err: RepositoryError) -\u003e Self {\n        match err {\n            RepositoryError::NotFound(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Not found: {}\", msg))\n            }\n            RepositoryError::Conflict(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Conflict: {}\", msg))\n            }\n            RepositoryError::Internal(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Internal: {}\", msg))\n            }\n            RepositoryError::Validation(msg) =\u003e {\n                RmcpError::RepositoryError(format!(\"Validation: {}\", msg))\n            }\n        }\n    }\n}\n\n/// MCP handler for get_symbols method\npub struct GetSymbolsHandler {\n    // Repository for fetching symbols\n    symbol_repository: Arc\u003cdyn SymbolRepository\u003e,\n}\n\nimpl GetSymbolsHandler {\n    /// Create a new handler with the provided repository\n    pub fn new(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e Self {\n        GetSymbolsHandler { symbol_repository }\n    }\n\n    /// Convert a domain Symbol to a DTO for the API\n    fn to_dto(symbol: \u0026Symbol) -\u003e SymbolDTO {\n        SymbolDTO {\n            id: symbol.id.clone(),\n            name: symbol.name.clone(),\n            category: symbol.category.clone(),\n            description: symbol.description.clone(),\n            related_symbols: symbol.related_symbols.clone(),\n        }\n    }\n}\n\n#[async_trait]\nimpl Handler for GetSymbolsHandler {\n    /// The method name this handler responds to\n    fn method_name(\u0026self) -\u003e \u0026str {\n        \"get_symbols\"\n    }\n\n    /// Handle the MCP method call\n    async fn handle(\u0026self, call: MethodCall) -\u003e Result\u003cserde_json::Value, RmcpError\u003e {\n        let params: GetSymbolsParams = call.parse_params()?;\n\n        // Fetch symbols from the repository\n        let symbols = match (params.category.as_deref(), params.query.as_deref()) {\n            // If we have a query, search for it\n            (_, Some(query)) =\u003e self.symbol_repository.search_symbols(query).await?,\n            // If we have just a category, filter by it\n            (Some(category), None) =\u003e self.symbol_repository.list_symbols(Some(category)).await?,\n            // No filters, list all symbols\n            (None, None) =\u003e self.symbol_repository.list_symbols(None).await?,\n        };\n\n        // Apply limit\n        let symbols = symbols\n            .iter()\n            .take(params.limit)\n            .map(|s| Self::to_dto(s))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let total_count = symbols.len();\n\n        Ok(serde_json::to_value(GetSymbolsResponse {\n            symbols,\n            total_count,\n        })?)\n    }\n}\n\n/// Factory function to create the get_symbols handler with provided repository\npub fn get_symbols(symbol_repository: Arc\u003cdyn SymbolRepository\u003e) -\u003e GetSymbolsHandler {\n    GetSymbolsHandler::new(symbol_repository)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::infrastructure::memory_repository::MemoryRepositoryFactory;\n    use serde_json::json;\n\n    #[tokio::test]\n    async fn test_get_symbols_handler() {\n        // Create a real repository with test data\n        let factory = MemoryRepositoryFactory::new().with_test_data();\n        let repository = factory.create_symbol_repository();\n\n        let handler = GetSymbolsHandler::new(repository);\n\n        // Create a method call with empty params\n        let call = MethodCall {\n            id: \"test-call\".to_string(),\n            method: \"get_symbols\".to_string(),\n            params: json!({}),\n        };\n\n        let result = handler.handle(call).await;\n\n        assert!(result.is_ok());\n        let response = result.unwrap();\n\n        // Validate response structure\n        assert!(response.is_object());\n        assert!(response.as_object().unwrap().contains_key(\"symbols\"));\n        assert!(response.as_object().unwrap().contains_key(\"total_count\"));\n\n        // We should have some symbols from the test data\n        assert!(response[\"total_count\"].as_u64().unwrap() \u003e 0);\n    }\n\n    #[test]\n    fn test_method_name() {\n        let factory = MemoryRepositoryFactory::new();\n        let repository = factory.create_symbol_repository();\n\n        let handler = GetSymbolsHandler::new(repository);\n        assert_eq!(handler.method_name(), \"get_symbols\");\n    }\n\n    #[test]\n    fn test_error_codes() {\n        let error = RmcpError::ParseError(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32602); // InvalidParams\n\n        let error = RmcpError::RepositoryError(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32000); // ServerError\n\n        let error = RmcpError::Other(\"test error\".to_string());\n        assert_eq!(error.error_code().code(), -32603); // InternalError\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":5}},{"line":27,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":8}},{"line":165,"address":[],"length":0,"stats":{"Line":20}},{"line":167,"address":[],"length":0,"stats":{"Line":20}},{"line":168,"address":[],"length":0,"stats":{"Line":20}},{"line":169,"address":[],"length":0,"stats":{"Line":20}},{"line":170,"address":[],"length":0,"stats":{"Line":20}},{"line":171,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":5}},{"line":185,"address":[],"length":0,"stats":{"Line":10}},{"line":188,"address":[],"length":0,"stats":{"Line":5}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":20}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}}],"covered":29,"coverable":76},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","methods","mod.rs"],"content":"// Exports the method modules\npub mod get_symbols;\npub use get_symbols::get_symbols;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","mod.rs"],"content":"pub mod methods;\npub mod schema;\n\n// We're not using the get_symbols function for now\n// pub use methods::get_symbols;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","mcp","schema.rs"],"content":"use rmcp::schemars;\nuse serde::{Deserialize, Serialize};\n\n/// Parameters for the get_symbols MCP method\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct GetSymbolsParams {\n    /// Category filter (dream, mythological, etc.)\n    pub category: Option\u003cString\u003e,\n\n    /// Search query for symbol names or descriptions\n    pub query: Option\u003cString\u003e,\n\n    /// Maximum number of symbols to return\n    #[serde(default = \"default_limit\")]\n    pub limit: usize,\n}\n\nfn default_limit() -\u003e usize {\n    50\n}\n\n/// Response for the get_symbols MCP method\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct GetSymbolsResponse {\n    /// List of symbols matching the query\n    pub symbols: Vec\u003cSymbolDTO\u003e,\n\n    /// Total count of symbols matching the query (for pagination)\n    pub total_count: usize,\n}\n\n/// Data transfer object for Symbol, used in MCP responses\n#[derive(Debug, Clone, Serialize, Deserialize, schemars::JsonSchema)]\npub struct SymbolDTO {\n    /// Unique identifier for the symbol\n    pub id: String,\n\n    /// Name of the symbol\n    pub name: String,\n\n    /// Category of the symbol\n    pub category: String,\n\n    /// Brief description of the symbol\n    pub description: String,\n\n    /// Related symbol IDs\n    pub related_symbols: Vec\u003cString\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::{self, json};\n\n    #[test]\n    fn test_get_symbols_params_serialization() {\n        let params = GetSymbolsParams {\n            category: Some(\"dream\".to_string()),\n            query: Some(\"water\".to_string()),\n            limit: 10,\n        };\n\n        let json = serde_json::to_value(params).unwrap();\n\n        assert_eq!(json[\"category\"], \"dream\");\n        assert_eq!(json[\"query\"], \"water\");\n        assert_eq!(json[\"limit\"], 10);\n    }\n\n    #[test]\n    fn test_get_symbols_params_default_limit() {\n        let params = GetSymbolsParams {\n            category: None,\n            query: None,\n            limit: default_limit(),\n        };\n\n        assert_eq!(params.limit, 50);\n    }\n\n    #[test]\n    fn test_symbol_dto_serialization() {\n        let symbol = SymbolDTO {\n            id: \"water\".to_string(),\n            name: \"Water\".to_string(),\n            category: \"dream\".to_string(),\n            description: \"Symbolizes emotions\".to_string(),\n            related_symbols: vec![\"ocean\".to_string(), \"river\".to_string()],\n        };\n\n        let json = serde_json::to_value(symbol).unwrap();\n\n        assert_eq!(json[\"id\"], \"water\");\n        assert_eq!(json[\"name\"], \"Water\");\n        assert_eq!(json[\"category\"], \"dream\");\n        assert_eq!(json[\"description\"], \"Symbolizes emotions\");\n        assert_eq!(json[\"related_symbols\"][0], \"ocean\");\n        assert_eq!(json[\"related_symbols\"][1], \"river\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":7}},{"line":19,"address":[],"length":0,"stats":{"Line":7}}],"covered":2,"coverable":2},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","src","utils","mod.rs"],"content":"// Utility functions for the application\npub fn version() -\u003e \u0026'static str {\n    env!(\"CARGO_PKG_VERSION\")\n}\n\n// Error handling utilities will be added here\n","traces":[{"line":2,"address":[],"length":0,"stats":{"Line":0}},{"line":3,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","api","handlers_tests.rs"],"content":"use std::sync::Arc;\n\nuse axum::{Json, extract::State, http::StatusCode};\n\n// We need to import directly from the crate\nuse dream_ontology_mcp::domain::RepositoryFactory;\nuse dream_ontology_mcp::domain::SymbolRepository;\nuse dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\n\n// Add a dependency on the correct modules instead of using API modules\n#[tokio::test]\nasync fn test_list_symbols_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // For now, we won't test the API directly, but just verify repository works\n    let symbols = repository.list_symbols(None).await.unwrap();\n\n    // Validate response\n    assert!(!symbols.is_empty());\n}\n\n#[tokio::test]\nasync fn test_get_symbol_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Get the first symbol from the repo to test with\n    let symbols = repository.list_symbols(None).await.unwrap();\n    let first_symbol = symbols.first().unwrap();\n\n    // Test direct repository call\n    let result = repository.get_symbol(\u0026first_symbol.id).await;\n\n    // Validate response\n    assert!(result.is_ok());\n    let symbol = result.unwrap();\n    assert_eq!(symbol.id, first_symbol.id);\n}\n\n#[tokio::test]\nasync fn test_search_symbols_integration() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Get the first symbol from the repo to test with\n    let symbols = repository.list_symbols(None).await.unwrap();\n    let first_symbol = symbols.first().unwrap();\n\n    // Search symbols using query from the first symbol (should find it)\n    let query = \u0026first_symbol.name[0..3]; // Use first few characters of name\n    let search_results = repository.search_symbols(query).await.unwrap();\n\n    // Validate response\n    assert!(!search_results.is_empty());\n    assert!(search_results.iter().any(|s| s.id == first_symbol.id));\n}\n\n#[tokio::test]\nasync fn test_error_handling_symbol_not_found() {\n    // Set up repository with test data\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    // Call repository with nonexistent ID\n    let result = repository.get_symbol(\"nonexistent-id\").await;\n\n    // Validate error response\n    assert!(result.is_err());\n    match result {\n        Err(err) =\u003e {\n            let error_string = err.to_string();\n            assert!(error_string.contains(\"Not found\"));\n        }\n        _ =\u003e panic!(\"Expected error response\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","api","mod.rs"],"content":"// API test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// API integration tests\npub mod handlers_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","fixtures.rs"],"content":"use dream_ontology_mcp::domain::{Symbol, SymbolSet};\n\n/// Create a test symbol with basic properties\npub fn create_test_symbol(id: \u0026str, name: \u0026str, category: \u0026str) -\u003e Symbol {\n    Symbol::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        format!(\"Description for {}\", name),\n    )\n}\n\n/// Create a test symbol with additional properties\npub fn create_detailed_symbol(\n    id: \u0026str,\n    name: \u0026str,\n    category: \u0026str,\n    description: \u0026str,\n    interpretations: Vec\u003c(\u0026str, \u0026str)\u003e,\n    related_symbols: Vec\u003c\u0026str\u003e,\n) -\u003e Symbol {\n    let mut symbol = Symbol::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        description.to_string(),\n    );\n\n    // Add interpretations\n    for (context, interpretation) in interpretations {\n        symbol.add_interpretation(context.to_string(), interpretation.to_string());\n    }\n\n    // Add related symbols\n    for related in related_symbols {\n        symbol.add_related_symbol(related.to_string());\n    }\n\n    symbol\n}\n\n/// Create a test symbol set with sample symbols\npub fn create_test_symbol_set(\n    id: \u0026str,\n    name: \u0026str,\n    category: \u0026str,\n    description: \u0026str,\n) -\u003e SymbolSet {\n    let mut symbol_set = SymbolSet::new(\n        id.to_string(),\n        name.to_string(),\n        category.to_string(),\n        description.to_string(),\n    );\n\n    // Add some sample symbols\n    symbol_set.add_symbol(create_test_symbol(\"water\", \"Water\", \"dream\"));\n    symbol_set.add_symbol(create_test_symbol(\"fire\", \"Fire\", \"dream\"));\n    symbol_set.add_symbol(create_test_symbol(\"mountain\", \"Mountain\", \"dream\"));\n\n    symbol_set\n}\n\n/// Create a populated dream symbols set\npub fn create_dream_symbols() -\u003e SymbolSet {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols appearing in dreams\".to_string(),\n    );\n\n    // Water symbol with interpretations\n    let water = create_detailed_symbol(\n        \"water\",\n        \"Water\",\n        \"dream\",\n        \"Symbolizes emotions and the unconscious\",\n        vec![\n            (\n                \"psychology\",\n                \"Represents the depths of the unconscious mind\",\n            ),\n            (\"spiritual\", \"Symbol of purification and renewal\"),\n        ],\n        vec![\"ocean\", \"river\"],\n    );\n\n    // Fire symbol with interpretations\n    let fire = create_detailed_symbol(\n        \"fire\",\n        \"Fire\",\n        \"dream\",\n        \"Symbolizes transformation and passion\",\n        vec![\n            (\"psychology\", \"Represents energy, desire or anger\"),\n            (\"spiritual\", \"Symbol of enlightenment and purification\"),\n        ],\n        vec![\"light\", \"sun\"],\n    );\n\n    // Add symbols to the set\n    symbol_set.add_symbol(water);\n    symbol_set.add_symbol(fire);\n\n    symbol_set\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","mock_repository.rs"],"content":"use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\n\nuse dream_ontology_mcp::domain::{\n    RepositoryError, RepositoryFactory, RepositoryResult, Symbol, SymbolRepository, SymbolSet,\n    SymbolSetRepository,\n};\n\nuse super::fixtures;\n\n/// Mock repository that allows customizing behavior for tests\npub struct MockSymbolRepository {\n    symbols: Arc\u003cRwLock\u003cHashMap\u003cString, Symbol\u003e\u003e\u003e,\n    fail_next_operation: Arc\u003cRwLock\u003cOption\u003cRepositoryError\u003e\u003e\u003e,\n}\n\nimpl MockSymbolRepository {\n    pub fn new() -\u003e Self {\n        MockSymbolRepository {\n            symbols: Arc::new(RwLock::new(HashMap::new())),\n            fail_next_operation: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        let test_symbols = vec![\n            fixtures::create_test_symbol(\"water\", \"Water\", \"dream\"),\n            fixtures::create_test_symbol(\"fire\", \"Fire\", \"dream\"),\n            fixtures::create_test_symbol(\"mountain\", \"Mountain\", \"dream\"),\n        ];\n\n        let mut symbols_map = HashMap::new();\n        for symbol in test_symbols {\n            symbols_map.insert(symbol.id.clone(), symbol);\n        }\n        *self.symbols.write().unwrap() = symbols_map;\n        self\n    }\n\n    /// Makes the next repository operation fail with the specified error\n    pub fn fail_next(\u0026self, error: RepositoryError) {\n        *self.fail_next_operation.write().unwrap() = Some(error);\n    }\n\n    /// Helper to check and consume the next failure if one is set\n    fn check_failure(\u0026self) -\u003e Result\u003c(), RepositoryError\u003e {\n        let mut fail_guard = self.fail_next_operation.write().unwrap();\n        if let Some(err) = fail_guard.take() {\n            return Err(err);\n        }\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl SymbolRepository for MockSymbolRepository {\n    async fn get_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        symbols\n            .get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found\",\n                id\n            )))\n    }\n\n    async fn list_symbols(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        let symbols: Vec\u003cSymbol\u003e = match category {\n            Some(cat) =\u003e symbols\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e symbols.values().cloned().collect(),\n        };\n\n        Ok(symbols)\n    }\n\n    async fn search_symbols(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbol\u003e\u003e {\n        self.check_failure()?;\n\n        let symbols = self.symbols.read().unwrap();\n        let query = query.to_lowercase();\n\n        let results: Vec\u003cSymbol\u003e = symbols\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(results)\n    }\n\n    async fn create_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"Symbol with ID {} already exists\",\n                symbol.id\n            )));\n        }\n\n        let symbol_clone = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n        Ok(symbol_clone)\n    }\n\n    async fn update_symbol(\u0026self, symbol: Symbol) -\u003e RepositoryResult\u003cSymbol\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if !symbols.contains_key(\u0026symbol.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found for update\",\n                symbol.id\n            )));\n        }\n\n        let symbol_clone = symbol.clone();\n        symbols.insert(symbol.id.clone(), symbol);\n        Ok(symbol_clone)\n    }\n\n    async fn delete_symbol(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        self.check_failure()?;\n\n        let mut symbols = self.symbols.write().unwrap();\n        if !symbols.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"Symbol with ID {} not found for deletion\",\n                id\n            )));\n        }\n\n        symbols.remove(id);\n        Ok(())\n    }\n}\n\n/// Mock SymbolSet repository for testing\npub struct MockSymbolSetRepository {\n    symbol_sets: Arc\u003cRwLock\u003cHashMap\u003cString, SymbolSet\u003e\u003e\u003e,\n    fail_next_operation: Arc\u003cRwLock\u003cOption\u003cRepositoryError\u003e\u003e\u003e,\n}\n\nimpl MockSymbolSetRepository {\n    pub fn new() -\u003e Self {\n        MockSymbolSetRepository {\n            symbol_sets: Arc::new(RwLock::new(HashMap::new())),\n            fail_next_operation: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        let test_sets = vec![\n            fixtures::create_test_symbol_set(\n                \"dream-symbols\",\n                \"Dream Symbols\",\n                \"dream\",\n                \"Common symbols in dreams\",\n            ),\n            fixtures::create_test_symbol_set(\n                \"myth-symbols\",\n                \"Mythological Symbols\",\n                \"mythological\",\n                \"Symbols from mythology\",\n            ),\n        ];\n\n        let mut sets_map = HashMap::new();\n        for set in test_sets {\n            sets_map.insert(set.id.clone(), set);\n        }\n        *self.symbol_sets.write().unwrap() = sets_map;\n        self\n    }\n\n    /// Makes the next repository operation fail with the specified error\n    pub fn fail_next(\u0026self, error: RepositoryError) {\n        *self.fail_next_operation.write().unwrap() = Some(error);\n    }\n\n    /// Helper to check and consume the next failure if one is set\n    fn check_failure(\u0026self) -\u003e Result\u003c(), RepositoryError\u003e {\n        let mut fail_guard = self.fail_next_operation.write().unwrap();\n        if let Some(err) = fail_guard.take() {\n            return Err(err);\n        }\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl SymbolSetRepository for MockSymbolSetRepository {\n    async fn get_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        sets.get(id)\n            .cloned()\n            .ok_or(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found\",\n                id\n            )))\n    }\n\n    async fn list_symbol_sets(\u0026self, category: Option\u003c\u0026str\u003e) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        let sets: Vec\u003cSymbolSet\u003e = match category {\n            Some(cat) =\u003e sets\n                .values()\n                .filter(|s| s.category == cat)\n                .cloned()\n                .collect(),\n            None =\u003e sets.values().cloned().collect(),\n        };\n\n        Ok(sets)\n    }\n\n    async fn search_symbol_sets(\u0026self, query: \u0026str) -\u003e RepositoryResult\u003cVec\u003cSymbolSet\u003e\u003e {\n        self.check_failure()?;\n\n        let sets = self.symbol_sets.read().unwrap();\n        let query = query.to_lowercase();\n\n        let results: Vec\u003cSymbolSet\u003e = sets\n            .values()\n            .filter(|s| {\n                s.name.to_lowercase().contains(\u0026query)\n                    || s.description.to_lowercase().contains(\u0026query)\n            })\n            .cloned()\n            .collect();\n\n        Ok(results)\n    }\n\n    async fn create_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if sets.contains_key(\u0026symbol_set.id) {\n            return Err(RepositoryError::Conflict(format!(\n                \"SymbolSet with ID {} already exists\",\n                symbol_set.id\n            )));\n        }\n\n        let set_clone = symbol_set.clone();\n        sets.insert(symbol_set.id.clone(), symbol_set);\n        Ok(set_clone)\n    }\n\n    async fn update_symbol_set(\u0026self, symbol_set: SymbolSet) -\u003e RepositoryResult\u003cSymbolSet\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if !sets.contains_key(\u0026symbol_set.id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found for update\",\n                symbol_set.id\n            )));\n        }\n\n        let set_clone = symbol_set.clone();\n        sets.insert(symbol_set.id.clone(), symbol_set);\n        Ok(set_clone)\n    }\n\n    async fn delete_symbol_set(\u0026self, id: \u0026str) -\u003e RepositoryResult\u003c()\u003e {\n        self.check_failure()?;\n\n        let mut sets = self.symbol_sets.write().unwrap();\n        if !sets.contains_key(id) {\n            return Err(RepositoryError::NotFound(format!(\n                \"SymbolSet with ID {} not found for deletion\",\n                id\n            )));\n        }\n\n        sets.remove(id);\n        Ok(())\n    }\n}\n\n/// Mock repository factory for testing\npub struct MockRepositoryFactory {\n    symbol_repository: Arc\u003cMockSymbolRepository\u003e,\n    symbol_set_repository: Arc\u003cMockSymbolSetRepository\u003e,\n}\n\nimpl MockRepositoryFactory {\n    pub fn new() -\u003e Self {\n        MockRepositoryFactory {\n            symbol_repository: Arc::new(MockSymbolRepository::new()),\n            symbol_set_repository: Arc::new(MockSymbolSetRepository::new()),\n        }\n    }\n\n    pub fn with_test_data(self) -\u003e Self {\n        // Create new instances with test data\n        let symbol_repo = MockSymbolRepository::new().with_test_data();\n        let symbol_set_repo = MockSymbolSetRepository::new().with_test_data();\n\n        MockRepositoryFactory {\n            symbol_repository: Arc::new(symbol_repo),\n            symbol_set_repository: Arc::new(symbol_set_repo),\n        }\n    }\n}\n\nimpl RepositoryFactory for MockRepositoryFactory {\n    fn create_symbol_repository(\u0026self) -\u003e Arc\u003cdyn SymbolRepository\u003e {\n        self.symbol_repository.clone()\n    }\n\n    fn create_symbol_set_repository(\u0026self) -\u003e Arc\u003cdyn SymbolSetRepository\u003e {\n        self.symbol_set_repository.clone()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","common","mod.rs"],"content":"pub mod fixtures;\npub mod mock_repository;\n\n/// Initialize test environment\npub fn setup() {\n    // Initialize any common test setup here\n    // For example, tracing setup for tests\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","mod.rs"],"content":"pub mod symbol_tests;\npub mod symbolset_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","symbol_tests.rs"],"content":"use dream_ontology_mcp::domain::Symbol;\n\n#[test]\nfn test_symbol_creation() {\n    let symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    assert_eq!(symbol.id, \"water\");\n    assert_eq!(symbol.name, \"Water\");\n    assert_eq!(symbol.category, \"dream\");\n    assert_eq!(symbol.description, \"Symbol of the unconscious\");\n    assert!(symbol.related_symbols.is_empty());\n    assert!(symbol.interpretations.is_empty());\n}\n\n#[test]\nfn test_symbol_interpretations() {\n    let mut symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    symbol.add_interpretation(\n        \"psychological\".to_string(),\n        \"Represents emotions and the unconscious mind\".to_string(),\n    );\n    symbol.add_interpretation(\n        \"spiritual\".to_string(),\n        \"Symbol of purification and renewal\".to_string(),\n    );\n\n    assert_eq!(symbol.interpretations.len(), 2);\n    assert_eq!(\n        symbol.interpretations.get(\"psychological\").unwrap(),\n        \"Represents emotions and the unconscious mind\"\n    );\n    assert_eq!(\n        symbol.interpretations.get(\"spiritual\").unwrap(),\n        \"Symbol of purification and renewal\"\n    );\n}\n\n#[test]\nfn test_symbol_related_symbols() {\n    let mut symbol = Symbol::new(\n        \"water\".to_string(),\n        \"Water\".to_string(),\n        \"dream\".to_string(),\n        \"Symbol of the unconscious\".to_string(),\n    );\n\n    symbol.add_related_symbol(\"ocean\".to_string());\n    symbol.add_related_symbol(\"river\".to_string());\n    symbol.add_related_symbol(\"lake\".to_string());\n\n    assert_eq!(symbol.related_symbols.len(), 3);\n    assert!(symbol.related_symbols.contains(\u0026\"ocean\".to_string()));\n    assert!(symbol.related_symbols.contains(\u0026\"river\".to_string()));\n    assert!(symbol.related_symbols.contains(\u0026\"lake\".to_string()));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","domain","symbolset_tests.rs"],"content":"use crate::common::fixtures;\nuse dream_ontology_mcp::domain::SymbolSet;\n\n#[test]\nfn test_symbolset_creation() {\n    let symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    assert_eq!(symbol_set.id, \"dream-symbols\");\n    assert_eq!(symbol_set.name, \"Dream Symbols\");\n    assert_eq!(symbol_set.category, \"dream\");\n    assert_eq!(symbol_set.description, \"Common symbols in dreams\");\n    assert_eq!(symbol_set.count(), 0);\n}\n\n#[test]\nfn test_symbolset_add_get_symbol() {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    // Add a test symbol\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n    symbol_set.add_symbol(symbol);\n\n    // Verify the symbol was added\n    assert_eq!(symbol_set.count(), 1);\n\n    // Retrieve and check the symbol\n    let retrieved = symbol_set.get_symbol(\"water\");\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().name, \"Water\");\n}\n\n#[test]\nfn test_symbolset_remove_symbol() {\n    let mut symbol_set = SymbolSet::new(\n        \"dream-symbols\".to_string(),\n        \"Dream Symbols\".to_string(),\n        \"dream\".to_string(),\n        \"Common symbols in dreams\".to_string(),\n    );\n\n    // Add a test symbol\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n    symbol_set.add_symbol(symbol);\n    assert_eq!(symbol_set.count(), 1);\n\n    // Remove the symbol\n    let removed = symbol_set.remove_symbol(\"water\");\n    assert!(removed.is_some());\n    assert_eq!(removed.unwrap().id, \"water\");\n\n    // Verify it was removed\n    assert_eq!(symbol_set.count(), 0);\n    assert!(symbol_set.get_symbol(\"water\").is_none());\n}\n\n#[test]\nfn test_symbolset_search() {\n    let symbol_set =\n        fixtures::create_test_symbol_set(\"test-set\", \"Test Set\", \"test\", \"Test symbol set\");\n\n    // Search for symbols containing \"water\"\n    let results = symbol_set.search(\"water\");\n    assert_eq!(results.len(), 1);\n    assert_eq!(results[0].id, \"water\");\n\n    // Search for symbols containing \"mountain\"\n    let results = symbol_set.search(\"mountain\");\n    assert_eq!(results.len(), 1);\n    assert_eq!(results[0].id, \"mountain\");\n\n    // Search with no matches\n    let results = symbol_set.search(\"xyz\");\n    assert_eq!(results.len(), 0);\n}\n\n#[test]\nfn test_symbolset_filter_by_category() {\n    let mut symbol_set = SymbolSet::new(\n        \"mixed-symbols\".to_string(),\n        \"Mixed Symbols\".to_string(),\n        \"mixed\".to_string(),\n        \"Mixed category symbols\".to_string(),\n    );\n\n    // Add symbols with different categories\n    symbol_set.add_symbol(fixtures::create_test_symbol(\"water\", \"Water\", \"dream\"));\n    symbol_set.add_symbol(fixtures::create_test_symbol(\n        \"dragon\",\n        \"Dragon\",\n        \"mythological\",\n    ));\n    symbol_set.add_symbol(fixtures::create_test_symbol(\"tree\", \"Tree\", \"dream\"));\n\n    // Filter by dream category\n    let dream_symbols = symbol_set.filter_by_category(\"dream\");\n    assert_eq!(dream_symbols.len(), 2);\n\n    // Filter by mythological category\n    let myth_symbols = symbol_set.filter_by_category(\"mythological\");\n    assert_eq!(myth_symbols.len(), 1);\n    assert_eq!(myth_symbols[0].id, \"dragon\");\n\n    // Filter by non-existent category\n    let empty_result = symbol_set.filter_by_category(\"nonexistent\");\n    assert_eq!(empty_result.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","lib.rs"],"content":"// This file serves as the main entry point for integration tests\n// It re-exports all test modules for organization\n\npub mod api;\npub mod common;\npub mod domain;\npub mod llm;\npub mod mcp;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","client_tests.rs"],"content":"use dream_ontology_mcp::llm::client::LlmClient;\n\n#[test]\nfn test_llm_client_creation() {\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n    let _default_client = LlmClient::with_default_model(\"test-api-key\".to_string());\n\n    // No assertions needed, we're just verifying the client can be created\n}\n\n#[tokio::test]\nasync fn test_llm_client_generate() {\n    // This is a placeholder test that would need mocking to properly test\n    // For now, we're just ensuring the method signatures are correct\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n\n    // This test would be enhanced with mocking in the future\n    // We're just testing that the code compiles for now\n}\n\n#[tokio::test]\nasync fn test_llm_client_chat() {\n    // This is a placeholder test that would need mocking to properly test\n    let _client = LlmClient::new(\"test-api-key\".to_string(), \"test-model\".to_string());\n\n    // This test would be enhanced with mocking in the future\n    // We're just testing that the code compiles for now\n}\n\n#[test]\nfn test_message_struct() {\n    use dream_ontology_mcp::llm::client::Message;\n\n    let message = Message {\n        role: \"user\".to_string(),\n        content: \"test content\".to_string(),\n    };\n\n    assert_eq!(message.role, \"user\");\n    assert_eq!(message.content, \"test content\");\n}\n\n#[test]\nfn test_completion_request_serialization() {\n    use dream_ontology_mcp::llm::client::{CompletionRequest, Message};\n    use serde_json::Value;\n\n    let request = CompletionRequest {\n        model: \"test-model\".to_string(),\n        messages: vec![\n            Message {\n                role: \"system\".to_string(),\n                content: \"You are a helpful assistant\".to_string(),\n            },\n            Message {\n                role: \"user\".to_string(),\n                content: \"Hello\".to_string(),\n            },\n        ],\n        temperature: Some(0.7),\n        max_tokens: Some(100),\n    };\n\n    let json = serde_json::to_value(request).unwrap();\n\n    assert_eq!(json[\"model\"], \"test-model\");\n    assert_eq!(json[\"messages\"][0][\"role\"], \"system\");\n    assert_eq!(\n        json[\"messages\"][0][\"content\"],\n        \"You are a helpful assistant\"\n    );\n    assert_eq!(json[\"messages\"][1][\"role\"], \"user\");\n    assert_eq!(json[\"messages\"][1][\"content\"], \"Hello\");\n\n    // For floating-point comparisons, check that the value exists and is approximately correct\n    assert!(json[\"temperature\"].is_number());\n    if let Value::Number(temp) = \u0026json[\"temperature\"] {\n        let temp_f64 = temp.as_f64().unwrap();\n        assert!((temp_f64 - 0.7).abs() \u003c 0.001);\n    }\n\n    assert_eq!(json[\"max_tokens\"], 100);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","mod.rs"],"content":"// LLM test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// These modules are commented out because we've removed the LLM functionality\n// as it belongs to the Dream Interpretation Backend, not the Symbolic Ontology Database\n// pub mod client_tests;\n// pub mod prompts_tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","llm","prompts_tests.rs"],"content":"use crate::common::fixtures;\nuse dream_ontology_mcp::llm::prompts::{build_symbol_prompt, build_system_prompt};\n\n#[test]\nfn test_build_system_prompt() {\n    let prompt = build_system_prompt(\"dream\");\n    assert!(prompt.contains(\"dream symbolism\"));\n\n    let prompt = build_system_prompt(\"mythological\");\n    assert!(prompt.contains(\"mythological symbolism\"));\n}\n\n#[test]\nfn test_build_symbol_prompt_basic() {\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n\n    // Test with no context or query\n    let basic_prompt = build_symbol_prompt(\u0026symbol, None, None);\n    assert!(basic_prompt.contains(\"Water\"));\n    assert!(basic_prompt.contains(\"Description for Water\"));\n    assert!(basic_prompt.contains(\"Consider general interpretive contexts\"));\n    assert!(basic_prompt.contains(\"Provide a general interpretation\"));\n}\n\n#[test]\nfn test_build_symbol_prompt_detailed() {\n    let symbol = fixtures::create_test_symbol(\"water\", \"Water\", \"dream\");\n\n    // Test with context and query\n    let detailed_prompt = build_symbol_prompt(\n        \u0026symbol,\n        Some(\"recurring nightmares\"),\n        Some(\"Why does this symbol appear during times of stress?\"),\n    );\n\n    assert!(detailed_prompt.contains(\"Consider the specific context: recurring nightmares\"));\n    assert!(detailed_prompt.contains(\n        \"Specifically address this question: Why does this symbol appear during times of stress?\"\n    ));\n}\n\n#[test]\nfn test_build_symbol_prompt_structure() {\n    let symbol = fixtures::create_detailed_symbol(\n        \"fire\",\n        \"Fire\",\n        \"dream\",\n        \"Symbol of transformation and passion\",\n        vec![\n            (\"psychology\", \"Represents energy, desire or anger\"),\n            (\"spiritual\", \"Symbol of enlightenment and purification\"),\n        ],\n        vec![\"light\", \"sun\"],\n    );\n\n    let prompt = build_symbol_prompt(\u0026symbol, None, None);\n\n    // Check for structured format sections\n    assert!(prompt.contains(\"Core symbolic meaning\"));\n    assert!(prompt.contains(\"Psychological significance\"));\n    assert!(prompt.contains(\"Cultural and historical context\"));\n    assert!(prompt.contains(\"Practical implications\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","mcp","get_symbols_tests.rs"],"content":"use dream_ontology_mcp::domain::RepositoryFactory;\nuse dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;\nuse dream_ontology_mcp::mcp::methods::get_symbols::{GetSymbolsHandler, Handler, MethodCall};\nuse serde_json::json;\n\n#[tokio::test]\nasync fn test_get_symbols_handler_name() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    assert_eq!(handler.method_name(), \"get_symbols\");\n}\n\n#[tokio::test]\nasync fn test_get_symbols_empty_params() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({}),\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Basic validation that we get a successful response with an array of symbols\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n    assert!(result.get(\"symbols\").unwrap().is_array());\n}\n\n#[tokio::test]\nasync fn test_get_symbols_with_category() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({ \"category\": \"nature\" }), // Using a category we know exists in test data\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Validate we get results filtered by category\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n\n    let symbols = result.get(\"symbols\").unwrap().as_array().unwrap();\n    // If we got any symbols, they should have the right category\n    if !symbols.is_empty() {\n        for symbol in symbols {\n            assert_eq!(symbol.get(\"category\").unwrap().as_str().unwrap(), \"nature\");\n        }\n    }\n}\n\n#[tokio::test]\nasync fn test_get_symbols_with_search() {\n    // Create a test repository\n    let factory = MemoryRepositoryFactory::new().with_test_data();\n    let repository = factory.create_symbol_repository();\n\n    let handler = GetSymbolsHandler::new(repository);\n    let call = MethodCall {\n        id: \"1\".to_string(),\n        method: \"get_symbols\".to_string(),\n        params: json!({ \"query\": \"light\" }), // Using \"query\" parameter as defined in schema\n    };\n\n    let result = handler.handle(call).await.unwrap();\n\n    // Just verify we get a response - test data might not have \"light\" references\n    assert!(result.is_object());\n    assert!(result.get(\"symbols\").is_some());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","mathiusjohnson","projects","dream-ontology-mcp","tests","mcp","mod.rs"],"content":"// MCP test modules will be added here\n// For now, this is a placeholder to satisfy the module structure\n\n// MCP test modules\npub mod get_symbols_tests;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>