diff --git a/Cargo.lock b/Cargo.lock
index 7da020b..4965ec5 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -553,6 +553,12 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "data-encoding"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2a2330da5de22e8a3cb63252ce2abb30116bf5265e89c0e01bc17015ce30a476"
+
 [[package]]
 name = "deflate64"
 version = "0.1.9"
@@ -630,20 +636,26 @@ dependencies = [
  "clap",
  "csv",
  "dotenvy",
+ "futures",
  "hyper",
+ "hyper-util",
  "pgvector",
+ "pin-project-lite",
  "reqwest",
  "rmcp",
  "serde",
  "serde_json",
  "sqlx 0.7.4",
  "tokio",
+ "tokio-stream",
  "tokio-test",
+ "tokio-tungstenite",
  "tokio-util",
  "tower",
  "tower-http",
  "tracing",
  "tracing-subscriber",
+ "uuid",
  "zip",
 ]
 
@@ -3046,6 +3058,18 @@ dependencies = [
  "tokio-stream",
 ]
 
+[[package]]
+name = "tokio-tungstenite"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c83b561d025642014097b66e6c1bb422783339e0909e4429cde4749d1990bc38"
+dependencies = [
+ "futures-util",
+ "log",
+ "tokio",
+ "tungstenite",
+]
+
 [[package]]
 name = "tokio-util"
 version = "0.7.15"
@@ -3175,6 +3199,25 @@ version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"
 
+[[package]]
+name = "tungstenite"
+version = "0.21.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ef1a641ea34f399a848dea702823bbecfb4c486f911735368f1f137cb8257e1"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http",
+ "httparse",
+ "log",
+ "rand 0.8.5",
+ "sha1",
+ "thiserror 1.0.69",
+ "url",
+ "utf-8",
+]
+
 [[package]]
 name = "typenum"
 version = "1.18.0"
@@ -3243,6 +3286,12 @@ version = "2.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "daf8dba3b7eb870caf1ddeed7bc9d2a049f3cfdfae7cb521b087cc33ae4c49da"
 
+[[package]]
+name = "utf-8"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"
+
 [[package]]
 name = "utf16_iter"
 version = "1.0.5"
@@ -3266,6 +3315,9 @@ name = "uuid"
 version = "1.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "458f7a779bf54acc9f347480ac654f68407d3aab21269a6e3c9f922acd9e2da9"
+dependencies = [
+ "getrandom 0.3.2",
+]
 
 [[package]]
 name = "valuable"
diff --git a/Cargo.toml b/Cargo.toml
index 2ccaec8..ecec174 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -8,6 +8,22 @@ edition = "2024"
 name = "dream_ontology_mcp"
 path = "src/lib.rs"
 
+[[bin]]
+name = "mcp_server"
+path = "src/bin/mcp_server.rs"
+
+[[bin]]
+name = "mcp_client"
+path = "src/bin/mcp_client.rs"
+
+[[bin]]
+name = "download_and_seed"
+path = "src/bin/download_and_seed.rs"
+
+[[bin]]
+name = "myth_seeder"
+path = "src/bin/myth_seeder.rs"
+
 [[test]]
 name = "integration"
 path = "tests/lib.rs"
@@ -19,14 +35,21 @@ axum = "0.8.3"
 axum-macros = "0.5.0"
 clap = { version = "4.5.5", features = ["derive"] }
 dotenvy = "0.15"
+futures = "0.3.30"
+hyper = { version = "1.6.0", features = ["full"] }
+hyper-util = { version = "0.1.3", features = ["tokio"] }
+pin-project-lite = "0.2.13"
 reqwest = { version = "0.12.15", features = ["json", "stream"] }
 rmcp = { version = "0.1.5", features = ["server", "transport-sse-server", "transport-sse", "client"] }
 serde = "1.0.219"
 serde_json = { version = "1.0.140", features = ["preserve_order"] }
 tokio = { version = "1.44.2", features = ["full", "macros"] }
+tokio-stream = "0.1.15"
+tokio-tungstenite = "0.21.0"
 tower-http = { version = "0.6.2", features = ["cors", "trace"] }
 tracing = "0.1.41"
 tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
+uuid = { version = "1.7.0", features = ["v4"] }
 # Database dependencies
 sqlx = { version = "0.7", features = ["runtime-tokio", "postgres", "json", "uuid", "time"] }
 pgvector = { version = "0.4", features = ["sqlx"] }
@@ -35,7 +58,5 @@ zip = "2.6.1"
 tokio-util = { version = "0.7.15", features = ["full"] }
 
 [dev-dependencies]
-hyper = { version = "1.6.0", features = ["full"] }
-tokio = { version = "1.44.2", features = ["macros", "rt-multi-thread"] }
 tokio-test = "0.4.4"
 tower = "0.5.2"
diff --git a/Dockerfile b/Dockerfile
index 7cdddb5..8c6784a 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -12,11 +12,29 @@ RUN cargo chef cook --release --recipe-path recipe.json
 # Build application
 COPY . .
 RUN cargo build --release --bin mcp_server
+RUN cargo build --release --bin mcp_websocket_server
+RUN cargo build --release --bin mcp_http_upgrade_server
+RUN cargo build --release --bin mcp_streamable_http_server
 
 # We do not need the Rust toolchain to run the binary!
 FROM debian:bookworm-slim AS runtime
 WORKDIR /app
 RUN apt-get update && apt-get install -y libssl3 ca-certificates && rm -rf /var/lib/apt/lists/*
+
+# Copy all server binaries
 COPY --from=builder /app/target/release/mcp_server /usr/local/bin
-EXPOSE 3002
+COPY --from=builder /app/target/release/mcp_websocket_server /usr/local/bin
+COPY --from=builder /app/target/release/mcp_http_upgrade_server /usr/local/bin
+COPY --from=builder /app/target/release/mcp_streamable_http_server /usr/local/bin
+
+# Copy test HTML files
+COPY test_websocket.html /app/
+COPY test_http_upgrade.html /app/
+COPY test_streamable_http.html /app/
+COPY test_all_servers.html /app/
+
+# Expose all ports
+EXPOSE 3002 3003 3004 3005
+
+# Default to running the original SSE server
 ENTRYPOINT ["/usr/local/bin/mcp_server"]
diff --git a/fly.toml b/fly.toml
index 38f76bb..536b624 100644
--- a/fly.toml
+++ b/fly.toml
@@ -1,8 +1,3 @@
-# fly.toml app configuration file generated for symbol-ontology on 2025-05-09T22:13:07-07:00
-#
-# See https://fly.io/docs/reference/configuration/ for information about how to use this file.
-#
-
 app = "symbolic-grounding-api"
 primary_region = "sea"
 
@@ -12,26 +7,70 @@ dockerfile = "Dockerfile"
 [env]
 PORT = "3002"
 
+# Increase HTTP timeout for SSE connections
+[http_service]
+internal_port = 3002
+force_https = true
+auto_stop_machines = false
+auto_start_machines = true
+min_machines_running = 1
+# Increase timeout for long-running SSE connections
+http_checks.grace_period = "120s"
+http_checks.interval = "30s"
+http_checks.timeout = "10s"
+http_checks.method = "GET"
+http_checks.path = "/message"
+
+[http_service.concurrency]
+type = "connections"
+hard_limit = 500
+soft_limit = 400
+
+[[http_service.cors]]
+allowed_origins = ["*"]
+allowed_methods = ["GET", "POST", "OPTIONS"]
+allowed_headers = ["*", "Cache-Control", "X-Requested-With", "Content-Type", "Accept", "Authorization"]
+exposed_headers = ["*", "Content-Type", "Cache-Control"]
+max_age = 86400
+
+# Health checks - use TCP check since there's no HTTP health endpoint
+[checks]
+[checks.alive]
+type = "tcp"
+interval = "60s"
+timeout = "30s"
+grace_period = "60s"
+
+# Additional services for different MCP server implementations
 [[services]]
+internal_port = 3003
 protocol = "tcp"
-internal_port = 3002
-processes = ["app"]
-
-  [services.concurrency]
-  type = "connections"
-  hard_limit = 250
-  soft_limit = 200
-
-  [[services.ports]]
-  port = 80
-  handlers = ["http"]
-  force_https = true
-
-  [[services.ports]]
-  port = 443
-  handlers = ["tls", "http"]
-
-  [services.tcp_checks]
-  interval = "30s"
-  timeout = "10s"
-  grace_period = "30s"
+auto_stop_machines = false
+auto_start_machines = true
+min_machines_running = 1
+
+[[services.ports]]
+port = 3003
+handlers = ["http", "tls"]
+
+[[services]]
+internal_port = 3004
+protocol = "tcp"
+auto_stop_machines = false
+auto_start_machines = true
+min_machines_running = 1
+
+[[services.ports]]
+port = 3004
+handlers = ["http", "tls"]
+
+[[services]]
+internal_port = 3005
+protocol = "tcp"
+auto_stop_machines = false
+auto_start_machines = true
+min_machines_running = 1
+
+[[services.ports]]
+port = 3005
+handlers = ["http", "tls"] 
\ No newline at end of file
diff --git a/src/bin/download_and_seed.rs b/src/bin/download_and_seed.rs
index f9e47e0..2035b7a 100644
--- a/src/bin/download_and_seed.rs
+++ b/src/bin/download_and_seed.rs
@@ -174,6 +174,35 @@ fn row_to_symbol(symbol_name: &str, interpretation: &str, description: Option<&s
     symbol
 }
 
+// Reset the database by deleting all symbols
+async fn reset_database(symbol_repo: Arc<dyn SymbolRepository>) -> Result<(), Box<dyn Error>> {
+    println!("Resetting database - clearing all symbols...");
+    
+    // Get all symbols
+    let symbols = symbol_repo.list_symbols(None).await?;
+    println!("Found {} symbols to delete", symbols.len());
+    
+    let mut deleted_count = 0;
+    
+    // Delete each symbol
+    for symbol in symbols {
+        match symbol_repo.delete_symbol(&symbol.id).await {
+            Ok(_) => {
+                deleted_count += 1;
+                if deleted_count % 100 == 0 {
+                    println!("Deleted {} symbols...", deleted_count);
+                }
+            },
+            Err(err) => {
+                eprintln!("Error deleting symbol {}: {}", symbol.id, err);
+            }
+        }
+    }
+    
+    println!("Database reset complete. Deleted {} symbols.", deleted_count);
+    Ok(())
+}
+
 async fn process_files_and_seed(
     database_url: &str,
     csv_files: Vec<PathBuf>,
@@ -184,6 +213,9 @@ async fn process_files_and_seed(
     let factory = PostgresRepositoryFactory::new(database_url).await?;
     let symbol_repo = factory.create_symbol_repository();
 
+    // Reset the database first
+    reset_database(symbol_repo.clone()).await?;
+
     // Track processed symbols to avoid duplicates
     let mut processed_symbols = HashSet::new();
     let mut success_count = 0;
diff --git a/src/bin/mcp_server.rs b/src/bin/mcp_server.rs
index a0aa69e..75c8a2e 100644
--- a/src/bin/mcp_server.rs
+++ b/src/bin/mcp_server.rs
@@ -1,9 +1,15 @@
 use clap::Parser;
-use dream_ontology_mcp::domain::RepositoryFactory;
+use std::fs::File;
+use std::io::BufReader;
+use std::path::Path;
+use serde::{Deserialize, Serialize};
+use std::collections::HashMap;
+use dream_ontology_mcp::domain::{RepositoryFactory, Symbol};
 use dream_ontology_mcp::infrastructure::memory_repository::MemoryRepositoryFactory;
 use dream_ontology_mcp::logging::setup_logging;
 use dream_ontology_mcp::mcp::service::SymbolService;
-use rmcp::transport::sse_server::SseServer;
+use rmcp::transport::sse_server::{SseServer, SseServerConfig};
+use tokio_util::sync::CancellationToken;
 use tracing::info;
 
 /// Command line arguments for the MCP server
@@ -22,22 +28,116 @@ async fn main() -> anyhow::Result<()> {
     // Setup enhanced logging
     setup_logging().expect("Failed to set up logging");
 
-    // Initialize repository
-    let factory = MemoryRepositoryFactory::new().with_test_data();
+    // Initialize a new repository factory
+    let factory = MemoryRepositoryFactory::new();
+    
+    // Get the repository
     let repository = factory.create_symbol_repository();
+    
+    // Load myths from JSON file
+    let json_path = Path::new("data/myth-symbol-seed.json");
+    println!("Attempting to load symbols from: {}", json_path.display());
+    
+    if json_path.exists() {
+        let file = File::open(json_path).expect("Failed to open JSON file");
+        let reader = BufReader::new(file);
+        
+        #[derive(Debug, Deserialize, Serialize)]
+        struct SymbolData {
+            id: String,
+            name: String,
+            category: String,
+            description: String,
+            interpretations: HashMap<String, String>,
+            related_symbols: Vec<String>,
+            properties: HashMap<String, String>,
+        }
+        
+        let symbols_data: Vec<SymbolData> = serde_json::from_reader(reader)
+            .expect("Failed to parse JSON");
+        
+        println!("Read {} symbols from JSON file", symbols_data.len());
+        
+        // Convert and add each symbol to the repository
+        for data in symbols_data {
+            let mut symbol = Symbol::new(
+                data.id,
+                data.name,
+                data.category,
+                data.description
+            );
+            
+            symbol.interpretations = data.interpretations;
+            symbol.related_symbols = data.related_symbols;
+            symbol.properties = data.properties;
+            
+            println!("Adding symbol: {} ({})", symbol.name, symbol.category);
+            let _ = repository.create_symbol(symbol).await;
+        }
+    } else {
+        println!("JSON file not found: {}", json_path.display());
+    }
+
+    // Print all available symbols for debugging
+    println!("\n=== AVAILABLE SYMBOLS ===");
+    let symbols = repository.list_symbols(None).await.unwrap();
+    println!("Total symbols in repository: {}", symbols.len());
+    
+    // Print all symbols with 'wings' or 'fly' in their description or related_symbols
+    println!("\n=== FLYING RELATED SYMBOLS ===");
+    for symbol in &symbols {
+        let has_flying = symbol.name.to_lowercase().contains("fly")
+            || symbol.description.to_lowercase().contains("fly")
+            || symbol
+                .related_symbols
+                .iter()
+                .any(|s| s.to_lowercase().contains("fly") || s.to_lowercase().contains("wing"));
+  
+        let has_wings = symbol.name.to_lowercase().contains("wing")
+            || symbol.description.to_lowercase().contains("wing")
+            || symbol
+                .related_symbols
+                .iter()
+                .any(|s| s.to_lowercase().contains("wing"));
+  
+        if has_flying || has_wings {
+            println!("Symbol: {} ({})", symbol.name, symbol.category);
+            println!("  Description: {}", symbol.description);
+            println!("  Related: {:?}", symbol.related_symbols);
+            println!();
+        }
+    }
+    println!("==============================\n");
 
     // Start MCP server
     let port = std::env::var("PORT").unwrap_or_else(|_| args.port.to_string());
     let bind_address = format!("0.0.0.0:{}", port);
 
     info!("Starting MCP server on {}", bind_address);
+    info!("Server version: {}", env!("CARGO_PKG_VERSION"));
+
+    // Create a server configuration with custom paths
+    let config = SseServerConfig {
+        bind: bind_address.parse()?,
+        sse_path: "/sse".to_string(),
+        post_path: "/message".to_string(),
+        ct: CancellationToken::new(),
+    };
 
-    // Create the core SSE server
-    let server = SseServer::serve(bind_address.parse()?)
+    // Create the core SSE server with enhanced logging
+    info!("Creating SSE server with config: {:?}", config);
+    let server = SseServer::serve_with_config(config)
         .await?
-        .with_service(move || SymbolService::new(repository.clone()));
+        .with_service(move || {
+            info!("Creating new SymbolService instance");
+            SymbolService::new(repository.clone())
+        });
 
     info!("Server ready to accept connections");
+    info!("Connect to this server with: https://<your-domain>/sse");
+    info!(
+        "Use sessionId parameter for message endpoint: https://<your-domain>/message?sessionId=<id>"
+    );
 
     // Keep the server running until Ctrl+C
     tokio::signal::ctrl_c().await?;
diff --git a/src/infrastructure/memory_repository.rs b/src/infrastructure/memory_repository.rs
index e480add..6573bf1 100644
--- a/src/infrastructure/memory_repository.rs
+++ b/src/infrastructure/memory_repository.rs
@@ -3,7 +3,11 @@ use crate::domain::{
     SymbolSetRepository,
 };
 use async_trait;
+use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
+use std::fs::File;
+use std::io::BufReader;
+use std::path::Path;
 use std::sync::{Arc, RwLock};
 
 /// Generic repository trait for basic CRUD operations
@@ -37,6 +41,76 @@ impl MemoryRepositoryFactory {
         Self::default()
     }
 
+    /// Load symbols from a JSON file
+    pub fn with_json_data(self, json_path: impl AsRef<Path>) -> Self {
+        let path = json_path.as_ref();
+        println!("Attempting to load symbols from: {}", path.display());
+
+        if !path.exists() {
+            eprintln!("Warning: JSON file not found: {}", path.display());
+            return self;
+        }
+
+        match Self::read_symbols_from_json(path) {
+            Ok(loaded_symbols) => {
+                println!(
+                    "Successfully loaded {} symbols from JSON file",
+                    loaded_symbols.len()
+                );
+                let mut symbols = self.symbols.write().unwrap();
+
+                for symbol in loaded_symbols {
+                    println!("Adding symbol: {} ({})", symbol.name, symbol.category);
+                    symbols.insert(symbol.id.clone(), symbol);
+                }
+
+                println!("Total symbols in repository: {}", symbols.len());
+            }
+            Err(e) => {
+                eprintln!("Error loading symbols from JSON: {}", e);
+            }
+        }
+
+        self
+    }
+
+    /// Read symbols from a JSON file
+    fn read_symbols_from_json(path: &Path) -> Result<Vec<Symbol>, Box<dyn std::error::Error>> {
+        println!("Reading JSON file: {}", path.display());
+        let file = File::open(path)?;
+        let reader = BufReader::new(file);
+
+        #[derive(Debug, Deserialize, Serialize)]
+        struct SymbolData {
+            id: String,
+            name: String,
+            category: String,
+            description: String,
+            interpretations: std::collections::HashMap<String, String>,
+            related_symbols: Vec<String>,
+            properties: std::collections::HashMap<String, String>,
+        }
+
+        let symbols_data: Vec<SymbolData> = serde_json::from_reader(reader)?;
+
+        // Convert SymbolData to Symbol
+        let symbols: Vec<Symbol> = symbols_data
+            .into_iter()
+            .map(|data| {
+                let mut symbol = Symbol::new(data.id, data.name, data.category, data.description);
+
+                symbol.interpretations = data.interpretations;
+                symbol.related_symbols = data.related_symbols;
+                symbol.properties = data.properties;
+
+                symbol
+            })
+            .collect();
+
+        println!("Read {} symbols from JSON file", symbols.len());
+        Ok(symbols)
+    }
+
     pub fn with_test_data(self) -> Self {
         // Load test data
         let test_symbols = vec![
diff --git a/src/main.rs b/src/main.rs
index 19b5bd2..e424478 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -74,13 +74,17 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                 .await?;
             pg_factory.create_symbol_repository()
         } else {
-            info!("No database URL provided, falling back to in-memory repository with test data");
-            let memory_factory = MemoryRepositoryFactory::new().with_test_data();
+            info!("No database URL provided, falling back to in-memory repository with test data and mythology data");
+            let memory_factory = MemoryRepositoryFactory::new()
+                .with_test_data()
+                .with_json_data("data/myth-symbol-seed.json");
             memory_factory.create_symbol_repository()
         }
     } else {
-        info!("Using in-memory repository with test data");
-        let memory_factory = MemoryRepositoryFactory::new().with_test_data();
+        info!("Using in-memory repository with test data and mythology data");
+        let memory_factory = MemoryRepositoryFactory::new()
+            .with_test_data()
+            .with_json_data("data/myth-symbol-seed.json");
         memory_factory.create_symbol_repository()
     };
 
